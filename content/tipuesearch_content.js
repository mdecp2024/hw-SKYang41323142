var tipuesearch = {"pages": [{'title': 'About', 'text': '國立虎尾科技大學機械設計工程系 \n National Formosa University \n Department of Mechanical Design Engineering \n cp2024 計算機程式 \n 課程教材: \n Learn Python with Jupyter  ( site ,  ebook ) \n 教育版帳號\xa0microsoftonline 登入點:\xa0 https://login.microsoftonline.com/ \n Teams 線上教學: \n 以 "學號@nfu.edu.tw" 登入  https://login.microsoftonline.com/  Office 365 \n Teams 團隊代碼:  ldodwua \n 個人倉儲:  https://github.com/mdecp2024/hw-SKYang41323142 \n 個人網站:  https://mde.tw/cp2024/content/index.html\xa0 \n 其他資訊: \n cd2023_pj3ag4_zmq_football_4.7.7z \n cd2024_2b_g6_steel_ball_platform_nxopen_copsim.7z \n https://animated-fiesta-6949rp7w4vw7hxvqx-8081.app.github.dev/content/index.html \n', 'tags': '', 'url': 'About.html'}, {'title': 'Attendance', 'text': '出席 (10%) - 自行舉證評分 \n 自行利用 Github commits 提交記錄評分. \n', 'tags': '', 'url': 'Attendance.html'}, {'title': 'HW 1', 'text': '主題: 基於瀏覽器的分散式版次管理與整合程式開發環境 (10%) \n USB 隨身碟: \n 下載  python_2025_lite.7z  (428 MB, 解開壓縮後約 1.5 GB) \n Jupyter \n What are Github and Codespaces? \n Hello World - GitHub Docs \n 利用包含學號的字串作為帳號, 申請免費使用 Github. \n Python 課程教材:  https://www.learnpythonwithjupyter.com/  - PART 1 \n \n PART 1: Creating the basics 資料整理 (10%) \n 啟動可攜程式系統後, 在命令列中: \n y:\\>cd notebook \n y:\\notebook>jupyter lab --collaborative \n 進入  01_string_input_print.ipynb  練習如何修改 PART1 notebook 後存檔, 上傳至作業倉儲中的 downloads 目錄後, 透過  https://nbviewer.org/  將已經提交的  01_string_input_print.ipynb , 嵌入下列網頁中. \n \n 上列 iframe 標註的 html 語法: \n <iframe width="600" height="400" src="https://nbviewer.org/urls/mde.tw/cp2024_hw/downloads/01_string_input_print.ipynb"></iframe> \n 完成上述流程整理後, 請將 HW1 自評分數輸入 cp2024 自評表單中. \n', 'tags': '', 'url': 'HW 1.html'}, {'title': 'HW 1 Exam', 'text': '每六人為一組進行協同程式練習 \n 透過 Jupyterlab 協同網頁, 輪流指定各組編寫 Topic 1 相關的程式練習, 以及網頁內容 (localhost 與 Codespaces 環境)編輯. \n', 'tags': '', 'url': 'HW 1 Exam.html'}, {'title': 'w7', 'text': '\n', 'tags': '', 'url': 'w7.html'}, {'title': 'w10', 'text': '\xa0題目一 \n \n 題目二 \n \n 題目三 \n \n', 'tags': '', 'url': 'w10.html'}, {'title': 'w11', 'text': '1.\xa0 已知可以用 Python 程式 由上往下列印三角形 * , 或 由左往右列印三角形 * , 請將此程式延伸到可以在 10x10 的字元區域中, 以 "*" 字元列印出圓型區域. 完成後請將程式碼存入個人 Gist 後, 直接在個人作業網站中的 Brython 頁面中執行. (提示: ?src=gist_script_URL) \n 2. 已知可以在網頁中利用 Brython 繪製方格與塗色, 如下連結, 請設法修改此一程式, 直接將程式存入個人的 Gist, 並利用黑色方塊圍出一個圓形區域. \n 網頁上的方格與塗色 \n 3. 完成上列題目後, 請利用 Youtube 影片 簡報 個人的解題過程與心得. \n', 'tags': '', 'url': 'w11.html'}, {'title': 'w11_hw', 'text': '1.\xa0 已知可以用 Python 程式 由上往下列印三角形 * , 或 由左往右列印三角形 * , 請將此程式延伸到可以在 10x10 的字元區域中, 以 "*" 字元列印出圓型區域. 完成後請將程式碼存入個人 Gist 後, 直接在個人作業網站中的 Brython 頁面中執行. (提示: ?src=gist_script_URL) \n 2. 已知可以在網頁中利用 Brython 繪製方格與塗色, 如下連結, 請設法修改此一程式, 直接將程式存入個人的 Gist, 並利用黑色方塊圍出一個圓形區域. \n 網頁上的方格與塗色 \n 3. 完成上列題目後, 請利用 Youtube 影片 簡報 個人的解題過程與心得. \n 1.在 10x10 的字元區域中, 以 "*" 字元列印出圓型區域 (Gist) \n code: \n # 定義區域大小\nwidth = 41  # 橫向大小（更高解析度）\nheight = 21  # 縱向大小\n\n# 圓心位置\ncenter_x = width // 2  # 圓心 x 坐標，取寬度的一半\ncenter_y = height // 2  # 圓心 y 坐標，取高度的一半\n\n# 圓的半徑\nradius = 10  # 圓的半徑長度\n\n# 縱向縮放比例\nvertical_scale = 2.2  # 修正字元比例，使圓形看起來更接近真圓\n\n# 繪製圓形\nfor y in range(height):  # 遍歷每一行\n    for x in range(width):  # 遍歷每一列\n        # 計算每個點與圓心的距離\n        dx = x - center_x  # x 軸距離\n        dy = (y - center_y) * vertical_scale  # y 軸距離，乘以縱向縮放比例\n        distance_squared = dx ** 2 + dy ** 2  # 計算與圓心的平方距離\n        \n        # 使用不同字符根據距離漸變\n        if distance_squared <= radius ** 2:  # 判斷是否在圓的範圍內\n            if distance_squared > (radius - 1) ** 2:  # 判斷是否在邊界區域\n                print(".", end="")  # 邊界區域用 "."\n            else:\n                print("*", end="")  # 圓內區域用 "*"\n        else:\n            print(" ", end="")  # 圓外區域留空\n    print()  # 換行，開始下一行繪製 \n \n \n 2.使用 Brython\xa0圍出圓形方格區域 (Gist) \n code : \n from browser import html  # 引入 html 模組，用於建立 DOM 元素\nfrom browser import document as doc  # 引入 document，操作網頁內容\n\n# 利用 html 建立 canvas 超文件物件\ncanvas = html.CANVAS(width=400, height=400)  # 建立一個 400x400 的畫布\nbrython_div = doc["brython_div1"]  # 取得網頁中 id 為 brython_div1 的元素\nbrython_div <= canvas  # 將畫布加入到網頁中指定的 div 元素中\n\n# 每一格的 pixel 數\ngs = 20  # 定義每個網格的像素大小為 20px\n\n# canvas 的上下文\nctx = canvas.getContext("2d")  # 獲取 2D 繪圖上下文，進行繪圖操作\n\ndef dRect(lux, luy, w, h, s=1, c="lightgrey"):\n    """繪製網格框"""\n    ctx.lineWidth = s  # 設定框線寬度\n    ctx.strokeStyle = c  # 設定框線顏色\n    ctx.beginPath()  # 開始繪製路徑\n    ctx.rect(lux, luy, w, h)  # 繪製矩形，左上角座標 (lux, luy)，寬 w，高 h\n    ctx.stroke()  # 描繪路徑\n\ndef grid(width, height, grid_pix):\n    """繪製網格"""\n    for i in range(width):  # 遍歷每一列\n        for j in range(height):  # 遍歷每一行\n            dRect(i * grid_pix, j * grid_pix, grid_pix, grid_pix, 1, "lightgrey")  # 繪製單個網格框\n\ndef fill(x, y, color):\n    """填充顏色"""\n    ctx.fillStyle = color  # 設定填充顏色\n    ctx.fillRect(x * gs, y * gs, gs, gs)  # 填充矩形，位置 (x, y)，大小為 gs x gs\n\n# 繪製網格\ngrid(11, 11, gs)  # 繪製 11x11 的網格，每格大小為 gs\n\n# 定義圓的參數\nwidth, height = 11, 11  # 圖形範圍的寬與高（以網格單位表示）\ncenter_x, center_y = 5, 5  # 圓心座標（以網格單位表示）\nradius = 5  # 圓的半徑（以網格單位表示）\n\n# 填充圓形內部區域\nfor y in range(height):  # 遍歷每一行\n    for x in range(width):  # 遍歷每一列\n        # 計算點到圓心的距離\n        distance = ((x - center_x) ** 2 + (y - center_y) ** 2) ** 0.5  # 使用歐幾里得距離公式\n        if distance <= radius:  # 判斷是否在圓的範圍內\n            fill(x, y, "black")  # 在符合條件的點填充黑色 \n 邏輯說明 \n \n 修改 Brython 程式，根據圓的公式判斷每個方格是否位於圓形區域內。 \n 使用黑色塊填充圓形的方格。 \n \n', 'tags': '', 'url': 'w11_hw.html'}, {'title': 'w12_hw', 'text': '1. 請各組組員分別利用  Brython 以及 Jupyter lab  環境, 執行 可攜程式  notebook 目錄中的  01_string_input_print.ipynb 至\xa010_for_search.ipynb  筆記本程式, 完成後請將能在 Brython 執行的程式碼存入個人  Gist  後, 將各程式執行連結放入 w12_hw 網頁上. 最後請說明各範例中所使用的程式語法以及執行心得. \n 1.for迴圈跟print的範例程式 \n code  :\xa0 \n # 定義一個清單 \n fruits = ["蘋果", "香蕉", "橘子", "芒果"] \n # 用 for 迴圈列印每個水果 for fruit in fruits:  print(f"我最喜歡的水果之一是: {fruit}") \n My gist :  for迴圈跟print的範例程式 \n \n 執行心得 \n \n \n 學到的概念 \n \n for  迴圈的便利性：可以用於處理範圍內的數字或列表等集合資料。 \n 配合條件判斷後，可以輕鬆篩選數據或進行分類。 \n 使用  f-string  增強輸出的可讀性，讓結果更清楚。 \n \n \n \n 遇到的問題 \n \n 問題 ：剛開始不熟悉  range()  的起始與結束值。\n \n 解釋： range(start, end)  包含起始值但不包含結束值，因此需注意範圍邊界。 \n \n \n 解決方法 ：多次嘗試不同的範圍設置，熟悉  range()  的運作方式。 \n \n \n \n 2. for  迴圈與字串操作的範例程式 \n code  :\xa0 \n # 定義一個字串 text = "Hello, World!" \n # 使用 for 迴圈遍歷字串中的每個字元 for char in text:  print(f"字元: {char}") \n My gist :  for 迴圈與字串操作的範例程式 \n \n \n 執行心得 \n \n \n 學到的概念 \n \n 字串本質上是一個字元的集合，能夠像列表一樣進行遍歷。 \n 使用  for  迴圈結合  print() ，可以輕鬆觀察每個字元的內容。 \n \n \n \n', 'tags': '', 'url': 'w12_hw.html'}, {'title': 'w13_hw', 'text': 'My gist :  最終程式 \n 解題思考: 透過點座標的掃瞄, 先採用尺寸較大格點 (如每 10 pixel 掃描一點), 即可判定點群位於那一個特定區域並進行著色. 當掃描細至單一 pixel 時, 就可以完成區域著色. \n 另外, 透過 if 判定各點所在區域的條件組合, 可以就是否: \n 位於第一個圓內部 \n 位於第二個圓內部 \n 位於第一個正方形內部 \n 位於第二個正方形內部第一個正方形上方、下方、左方、右方 \n 位於第二個正方形上方、下方、左方、右方 \n 位於對角線上方範圍 \n 位於對角線下方範圍 \n 等條件 區分各區域的不同屬性 , 並設法利用這些區域屬性進行 顏色運算 . \n 接近正確 以及 更細化 的著色範例. \n rect_fill_1 \n rect_fill_2 \n  導入 brython 程式庫  \n \n \n  啟動 Brython  \n \n  畫布定位點  \n \n  利用 Brython 繪圖  \n \n code: \n <script type="text/python">// <![CDATA[\nfrom browser import html  # 匯入 HTML 元素模組\nfrom browser import document as doc  # 匯入文件操作模組\nimport math  # 匯入數學模組，用於計算圓弧\nimport random  # 匯入隨機模組，用於生成隨機顏色\n\n# 建立畫布\ncanvas = html.CANVAS(width=500, height=500)  # 建立一個 500x500px 的畫布\nbrython_div = doc["brython_div1"]  # 獲取 HTML 中 id 為 brython_div1 的 div\nbrython_div <= canvas  # 將畫布插入到指定的 div 中\nctx = canvas.getContext("2d")  # 獲取 2D 繪圖上下文\nctx.lineWidth = 4  # 設定筆觸寬度\n\n# 隨機顏色函數\ndef random_color():\n    return f"rgb({random.randint(0, 255)}, {random.randint(0, 255)}, {random.randint(0, 255)})" \n    # 返回隨機生成的 RGB 顏色\n\n# 畫布背景\nctx.fillStyle = "white"  # 設定背景顏色為白色\nctx.fillRect(0, 0, 500, 500)  # 填滿畫布\n\n# 畫分段圓形\ndef draw_segmented_circle(x, y, radius, segments):\n    """繪製分段圓形"""\n    for i in range(segments):  # 根據分段數量繪製多個圓弧\n        start_angle = (i / segments) * 2 * math.pi  # 計算起始角度\n        end_angle = ((i + 1) / segments) * 2 * math.pi  # 計算結束角度\n        ctx.beginPath()  # 開始繪製路徑\n        ctx.arc(x, y, radius, start_angle, end_angle)  # 繪製圓弧\n        ctx.lineTo(x, y)  # 連線到圓心\n        ctx.closePath()  # 封閉路徑\n        ctx.fillStyle = random_color()  # 設定填充顏色為隨機顏色\n        ctx.fill()  # 填充路徑\n        ctx.strokeStyle = "black"  # 設定邊框顏色為黑色\n        ctx.stroke()  # 繪製邊框\n\n# 畫三角形\ndef draw_triangle(vertices, color="red"):\n    """繪製三角形"""\n    ctx.beginPath()  # 開始繪製路徑\n    ctx.moveTo(*vertices[0])  # 移動到第一個頂點\n    for vertex in vertices[1:]:  # 遍歷剩餘頂點\n        ctx.lineTo(*vertex)  # 繪製邊\n    ctx.closePath()  # 封閉路徑\n    ctx.fillStyle = color  # 設定填充顏色\n    ctx.fill()  # 填充三角形\n    ctx.strokeStyle = "black"  # 設定邊框顏色為黑色\n    ctx.stroke()  # 繪製邊框\n\n# 畫斜線\ndef draw_line(start, end, color="blue"):\n    """繪製直線"""\n    ctx.strokeStyle = color  # 設定線條顏色\n    ctx.beginPath()  # 開始繪製路徑\n    ctx.moveTo(*start)  # 移動到起點\n    ctx.lineTo(*end)  # 繪製到終點\n    ctx.stroke()  # 繪製線條\n\n# 繪製內容\ndraw_segmented_circle(160, 160, 100, 6)  # 繪製第一個分段圓，中心在 (160, 160)\ndraw_segmented_circle(300, 300, 100, 6)  # 繪製第二個分段圓，中心在 (300, 300)\n\n# 繪製三角形區域\ndraw_triangle([(50, 50), (50, 250), (250, 250)], random_color())  # 第一個三角形\ndraw_triangle([(150, 150), (350, 150), (350, 350)], random_color())  # 第二個三角形\n\n# 繪製藍色斜線\ndraw_line((50, 50), (250, 250))  # 繪製從 (50, 50) 到 (250, 250) 的斜線\n// ]]>\n \n', 'tags': '', 'url': 'w13_hw.html'}, {'title': 'w14_hw', 'text': 'My gist : 最終程式 \n 根據兩個圓繪圖所圍成的 區域 (目前圍成三個區域, 但若圓心移動可能彼此獨立)進行不同顏色著色, 條件是當各圓半徑與圓心座標變動時, 程式只需輸入兩個圓的圓心座標與半徑, 就可以完成各區域的著色任務. \n  導入 Brython 程式庫  \n \n \n \n \n \n  畫布定位點  \n \n  利用 Brython 繪圖  \n \n \n code: \n from browser import html  # 匯入 html 模組，用於建立網頁中的 HTML 元素\nfrom browser import document as doc  # 匯入 document 模組，方便操作 DOM\nimport random  # 匯入 random 模組，用於生成隨機數\nimport math  # 匯入 math 模組，用於數學計算\n\n# 初始化畫布的函式\ndef initialize_canvas(canvas_width=400, canvas_height=400, id="brython_div1"):\n    canvas = html.CANVAS(width=canvas_width, height=canvas_height)  # 建立指定大小的畫布元素\n    brython_div = doc[id]  # 找到網頁中 id 為指定名稱的元素\n    brython_div <= canvas  # 將畫布元素添加到網頁中\n    ctx = canvas.getContext("2d")  # 獲取 2D 繪圖上下文\n    return canvas, ctx  # 返回畫布與上下文\n\n# 生成隨機顏色\ndef random_color_generator():\n    r = random.randint(0, 255)  # 隨機生成 0-255 的紅色值\n    g = random.randint(0, 255)  # 隨機生成 0-255 的綠色值\n    b = random.randint(0, 255)  # 隨機生成 0-255 的藍色值\n    return f"rgb({r}, {g}, {b})"  # 返回 RGB 顏色格式的字串\n\n# 判斷點是否在圓內\ndef is_point_in_circle(px, py, cx, cy, r):\n    return (px - cx) ** 2 + (py - cy) ** 2 <= r ** 2  # 計算點到圓心的平方距離，判斷是否小於等於半徑的平方\n\n# 繪製三個圓的區域塗色\ndef draw_three_circles(x1, y1, r1, x2, y2, r2, x3, y3, r3):\n    canvas, ctx = initialize_canvas(400, 400)  # 初始化畫布與繪圖上下文\n    ctx.clearRect(0, 0, canvas.width, canvas.height)  # 清空畫布\n    # 定義不同區域的顏色\n    color_dict = {}  # 用於儲存每個區域的顏色\n    for py in range(0, canvas.height):  # 遍歷畫布每一行像素\n        for px in range(0, canvas.width):  # 遍歷畫布每一列像素\n            # 判斷點是否在每個圓內\n            in_circle1 = is_point_in_circle(px, py, x1, y1, r1)  # 判斷點是否在第一個圓內\n            in_circle2 = is_point_in_circle(px, py, x2, y2, r2)  # 判斷點是否在第二個圓內\n            in_circle3 = is_point_in_circle(px, py, x3, y3, r3)  # 判斷點是否在第三個圓內\n            # 判斷區域類型\n            if in_circle1 and in_circle2 and in_circle3:  # 如果點在三個圓的交集區域內\n                if "intersection_all" not in color_dict:  # 若尚未為該區域定義顏色\n                    color_dict["intersection_all"] = random_color_generator()  # 為該區域生成顏色\n                current_color = color_dict["intersection_all"]  # 使用該區域的顏色\n            elif in_circle1 and in_circle2:  # 如果點在第一、第二圓的交集區域內\n                if "intersection_1_2" not in color_dict:  # 若尚未為該區域定義顏色\n                    color_dict["intersection_1_2"] = random_color_generator()  # 為該區域生成顏色\n                current_color = color_dict["intersection_1_2"]  # 使用該區域的顏色\n            elif in_circle1 and in_circle3:  # 如果點在第一、第三圓的交集區域內\n                if "intersection_1_3" not in color_dict:  # 若尚未為該區域定義顏色\n                    color_dict["intersection_1_3"] = random_color_generator()  # 為該區域生成顏色\n                current_color = color_dict["intersection_1_3"]  # 使用該區域的顏色\n            elif in_circle2 and in_circle3:  # 如果點在第二、第三圓的交集區域內\n                if "intersection_2_3" not in color_dict:  # 若尚未為該區域定義顏色\n                    color_dict["intersection_2_3"] = random_color_generator()  # 為該區域生成顏色\n                current_color = color_dict["intersection_2_3"]  # 使用該區域的顏色\n            elif in_circle1:  # 如果點僅在第一個圓內\n                if "circle1" not in color_dict:  # 若尚未為該區域定義顏色\n                    color_dict["circle1"] = random_color_generator()  # 為該區域生成顏色\n                current_color = color_dict["circle1"]  # 使用該區域的顏色\n            elif in_circle2:  # 如果點僅在第二個圓內\n                if "circle2" not in color_dict:  # 若尚未為該區域定義顏色\n                    color_dict["circle2"] = random_color_generator()  # 為該區域生成顏色\n                current_color = color_dict["circle2"]  # 使用該區域的顏色\n            elif in_circle3:  # 如果點僅在第三個圓內\n                if "circle3" not in color_dict:  # 若尚未為該區域定義顏色\n                    color_dict["circle3"] = random_color_generator()  # 為該區域生成顏色\n                current_color = color_dict["circle3"]  # 使用該區域的顏色\n            else:\n                current_color = "white"  # 如果點不在任何圓內，填充背景色\n            # 填充當前像素\n            ctx.fillStyle = current_color  # 設定填充顏色\n            ctx.fillRect(px, py, 1, 1)  # 填充 1x1 像素大小的矩形\n\n# 測試參數\nx1, y1, r1 = 150, 200, 100  # 第一個圓的圓心與半徑\nx2, y2, r2 = 250, 200, 100  # 第二個圓的圓心與半徑\nx3, y3, r3 = 200, 300, 100  # 第三個圓的圓心與半徑\n\n# 繪製三個圓的區域塗色\ndraw_three_circles(x1, y1, r1, x2, y2, r2, x3, y3, r3)  # 調用函式進行繪製\n \n', 'tags': '', 'url': 'w14_hw.html'}, {'title': 'w15', 'text': '題目一: \n 請利用 Gist 與 Brython 程式環境, 在個人的課程網站中新增一個頁面, 標題為 w15, 以" 從 1 累加到 100 "作為 anchor 的連結標題, 使用者點擊該連結之後, 可從各自的 Brython 頁面執行程式. \n # 初始化變數 sum，用來累計總和，初始值設為 0\nsum = 0\n\n# 使用 for 迴圈，從 0 遍歷到 100（包含 100）\nfor i in range(0, 101):  # range(0, 101) 會產生從 0 到 100 的整數序列\n    sum += i  # 將當前的數字 i 累加到 sum 中\n\n# 輸出最終累加的結果\nprint(sum)  # 輸出結果：5050 \n 題目二: \n 延伸上題, 設計一個函式  addto(1, 100) , 可以完成上述的累加結果. (以" addto "作為連結標題) \n def addto(start, end):\n    """\n    計算從 start 到 end 之間所有整數的總和。\n      \n    參數：\n    start: 開始的整數\n    end: 結束的整數（包含在內）\n  \n    返回：\n    整數總和\n    """\n    sum = 0  # 初始化總和為 0\n    for i in range(start, end + 1):  # 使用 for 迴圈，從 start 遍歷到 end（包括 end）\n        sum += i  # 將當前數字 i 加入總和 sum\n    return sum  # 返回計算的總和\n  \n# 測試函式\nresult = addto(1, 100)  # 調用 addto 函式，計算從 1 到 100 的總和\nprint(result)  # 使用 print 輸出函式的返回值\n \n 題目三: \n 延伸上題, 設計一個函式  add_only_even(1, 100) , 可以完成從第一個輸入整數, 累加到第二個輸入變數的累加結果. 頁面中請以  add_only_even \xa0作為連結標題. \n def addto(start, end):\n    """\n    計算從 start 到 end 之間所有整數的總和。\n      \n    參數：\n    start: 開始的整數\n    end: 結束的整數（包含在內）\n  \n    返回：\n    整數總和\n    """\n    sum = 0  # 初始化總和為 0\n    for i in range(start, end + 1):  # 從 start 累加到 end，包含 end\n        sum += i  # 將當前數字加入總和\n    return sum  # 返回計算的總和\n  \n# 測試函式\n    result = addto(1, 100)  # 計算 1 到 100 的總和\n    print(result)  # 輸出結果 \n 題目四:  \n 延伸上題, 設計一個函式  add_avoid_8 (1, 100), 可以完成從第一個輸入整數, 累加到第二個輸入變數的累加過程, 必須避開數字出現"8"的整數,\xa0頁面中請以  add_avoid_8  作為連結標題. \n # 定義 add_avoid_8 函式，接受兩個參數 start 和 end\ndef add_avoid_8(start, end):\n    """\n    計算從 start 到 end（包含 end）之間所有不包含數字 \'8\' 的數字總和\n    """\n    total_sum = 0  # 初始化總和為 0\n    # 遍歷從 start 到 end 之間的所有數字\n    for i in range(start, end + 1):  # 從 start 開始迴圈到 end，包含 end\n        # 將數字轉換為字符串並檢查是否包含 \'8\'\n        if \'8\' not in str(i):  # 如果 \'8\' 沒有出現在該數字的字符串表示中\n            total_sum += i  # 將當前數字加入總和\n    return total_sum  # 返回最終的累加和\n \n# 呼叫 add_avoid_8 函式，計算從 1 到 100 之間不包含數字 \'8\' 的數字總和\nresult = add_avoid_8(1, 100)  # 計算結果儲存到 result 變數中\n \n# 輸出結果\nprint(result)  # 輸出 result 變數的值\n \n 延伸第四題： add_avoid_8_and_3 (1 , 100 ) \n # 定義 add_avoid_8_and_3 函式，接受兩個參數 start 和 end\ndef add_avoid_8_and_3(start, end):\n    """\n    計算從 start 到 end（包含 end）之間所有不包含數字 \'8\' 或 \'3\' 的數字總和\n    """\n    total_sum = 0  # 初始化總和為 0\n    # 遍歷從 start 到 end 之間的所有數字\n    for i in range(start, end + 1):  # 使用 for 迴圈，從 start 遍歷到 end（包含 end）\n        # 將數字轉換為字符串並檢查是否包含 \'8\' 或 \'3\'\n        if \'8\' not in str(i) and \'3\' not in str(i):  # 如果數字中不包含 \'8\' 和 \'3\'\n            total_sum += i  # 將當前數字加到總和中\n    return total_sum  # 返回計算的總和\n \n# 呼叫 add_avoid_8_and_3 函式，計算從 1 到 100 之間不包含數字 \'8\' 或 \'3\' 的數字總和\nresult = add_avoid_8_and_3(1, 100)  # 將結果儲存到 result 變數中\n \n# 輸出結果\nprint(result)  # 輸出 result 的值\n \n 心得與收穫 \n \n 使用 Brython 的動態特性可以快速生成互動式網頁。 \n 函式化設計讓程式易於擴展，例如新增其他累加規則。 \n HTML 與 Brython 的結合提高了程式的可讀性與可操作性。 \n 理解了如何使用條件篩選與 Python 的字串操作來實現複雜功能。 \n \n \n  利用 Brython 繪圖  \n \n', 'tags': '', 'url': 'w15.html'}, {'title': 'HW 2', 'text': '主題: Python 的數列、判斷式與重複迴圈 (20%) \n Python 課程教材:  https://www.learnpythonwithjupyter.com/  - PART 2 and Part 3 \n \n 延續 HW 1 網頁資料整理與程式練習方法, 整理下列內容 (20%): \n PART 2: Introduction to lists and if/else statements \n PART 3: Introduction to the for loop \n 完成上述流程整理後, 請將 HW2 自評分數輸入 cp2024 自評表單中. \n', 'tags': '', 'url': 'HW 2.html'}, {'title': 'HW 2 Exam', 'text': '每六人為一組進行協同程式練習 \n 透過 Jupyterlab 協同網頁, 輪流指定各組編寫 HW 2 相關的程式練習, 以及網頁內容 (localhost 與 Codespaces 環境)編輯. \n', 'tags': '', 'url': 'HW 2 Exam.html'}, {'title': 'w16_exam1', 'text': '\n Brython Canvas Demo \n \n  畫布容器  \n \n  Brython 程式碼  \n \n 結構化設計 代碼結構清晰，層次分明，每段程式碼都專注於實現特定的圖形繪製功能，有助於後續的維護和修改。 透過使用 offset_x 和 offset_y，讓圖形定位以基準點為參考，使得排列與重新調整更加直觀與簡單。 多樣化形狀 示範了利用 Canvas API 繪製多種類型的幾何圖形，包括六邊形、菱形、三角形和圓形等。 使用鮮明的色彩區分不同形狀，進一步提升了視覺效果。 座標系統應用 通過繪製 X、Y 軸並標記原點，提供了明確的參考框架，方便後續進行圖形定位與設計調整。 \n sol: code \n Brython: code \n \n  導入 Brython 程式庫  \n \n \n  啟動 Brython  \n \n  畫布定位點  \n \n from browser import html  # 匯入 Brython 的 html 模組，用於操作 HTML 元素\nfrom browser import document as doc  # 匯入 Brython 的 document 物件，操作網頁中的 DOM\n\n# 創建畫布 (canvas)，並設置其大小為 2000x150 像素\ncanvas = html.CANVAS(width=2000, height=150)\n# 取得 HTML 中 id 為 brython_div1 的元素，這樣可以把畫布放置到這個元素中\nbrython_div = doc["brython_div1"]\n# 將畫布添加到 HTML 頁面中的指定元素中\nbrython_div <= canvas\n\n# 取得畫布的 2D 繪圖上下文，這樣我們才能在畫布上繪製圖形\nctx = canvas.getContext("2d")\n\n# 設置畫筆的寬度為 2 像素，這樣我們畫的線會較粗\nctx.lineWidth = 2\n# 設置畫筆的顏色為黑色\nctx.strokeStyle = "black"\n\n# 繪製 X 軸 (從原點 (31, 42) 向右延伸到 (88, 42))\nctx.beginPath()  # 開始繪製新的路徑\nctx.moveTo(31, 42)  # 將畫筆移動到 X 軸起始點 (31, 42)\nctx.lineTo(88, 42)  # 畫一條線到 X 軸終點 (88, 42)\nctx.stroke()  # 完成繪製並顯示這條線\n\n# 繪製 Y 軸 (從原點 (31, 42) 向下延伸到 (31, 134))\nctx.beginPath()  # 開始繪製新的路徑\nctx.moveTo(31, 42)  # 將畫筆移動到 Y 軸起始點 (31, 42)\nctx.lineTo(31, 134)  # 畫一條線到 Y 軸終點 (31, 134)\nctx.stroke()  # 完成繪製並顯示這條線\n\n# 設置字體樣式為 20px 的 Arial 字型，並設置文字顏色為黑色\nctx.font = "20px Arial"  # 設定字型為 Arial，大小為 20px\nctx.fillStyle = "black"  # 設定填充文字的顏色為黑色\n\n# 在畫布上 (90, 64) 位置添加文字 "+X"\nctx.fillText("+X", 90, 64)  # 在 X 軸正方向添加標籤 "+X"\n\n# 在畫布上 (20, 150) 位置添加文字 "+Y"\nctx.fillText("+Y", 20, 150)  # 在 Y 軸正方向添加標籤 "+Y"\n\n# 更改字體樣式為 12px 的 Arial 字型，用來標示原點座標\nctx.font = "12px Arial"  # 設定字型為 Arial，大小為 12px\nctx.fillStyle = "black"  # 設定填充文字的顏色為黑色\n# 在 (35, 59) 位置顯示文字 "(31, 42)"\nctx.fillText("(31, 42)", 35, 59)  # 在原點旁邊顯示座標 "(31, 42)"\n\n# 設置位移偏移量，x 和 y 變數對應新原點座標 (31, 42)\nx = 31  # 定義 x 為原點的 X 座標\ny = 42  # 定義 y 為原點的 Y 座標\n\n# 繪製橙色六邊形\nctx.beginPath()  # 開始繪製六邊形\nctx.fillStyle = "#EBB000"  # 設置填充顏色為橙色\nctx.moveTo(x + 40, y + 70)  # 六邊形的第一個頂點\nctx.lineTo(x + 60, y + 40)  # 第二個頂點\nctx.lineTo(x + 90, y + 40)  # 第三個頂點\nctx.lineTo(x + 110, y + 70)  # 第四個頂點\nctx.lineTo(x + 90, y + 100)  # 第五個頂點\nctx.lineTo(x + 60, y + 100)  # 第六個頂點\nctx.closePath()  # 關閉路徑，使六邊形封閉\nctx.fill()  # 填充六邊形的顏色\n\n# 繪製綠色菱形\nctx.beginPath()  # 開始繪製菱形\nctx.fillStyle = "#2CB05F"  # 設置填充顏色為綠色\nctx.moveTo(x + 130, y + 70)  # 菱形的第一個頂點\nctx.lineTo(x + 150, y + 40)  # 第二個頂點\nctx.lineTo(x + 170, y + 70)  # 第三個頂點\nctx.lineTo(x + 150, y + 100)  # 第四個頂點\nctx.closePath()  # 關閉路徑，將菱形閉合\nctx.fill()  # 填充菱形的顏色\n\n# 繪製藍色三角形\nctx.beginPath()  # 開始繪製三角形\nctx.fillStyle = "#73B7FF"  # 設置填充顏色為藍色\nctx.moveTo(x + 174, y + 70)  # 三角形的第一個頂點\nctx.lineTo(x + 154, y + 100)  # 第二個頂點（左下角）\nctx.lineTo(x + 194, y + 100)  # 第三個頂點（右下角）\nctx.closePath()  # 關閉路徑，將三角形閉合\nctx.fill()  # 填充三角形的顏色\n\n# 繪製粉紅色圓形\nctx.beginPath()  # 開始繪製圓形\nctx.fillStyle = "#FF458C"  # 設置填充顏色為粉紅色\nctx.arc(x + 220, y + 70, 20, 0, 2 * 3.14159)  # 定義圓形的圓心和半徑\nctx.fill()  # 填充圓形的顏色\n\n# 繪製黃色正方形\nctx.beginPath()  # 開始繪製正方形\nctx.fillStyle = "#EBDF00"  # 設置填充顏色為黃色\nctx.rect(x + 260, y + 43, 40, 40)  # 定義正方形的左上角和邊長\nctx.fill()  # 填充正方形的顏色\n\n# 繪製藍色矩形\nctx.beginPath()  # 開始繪製矩形\nctx.fillStyle = "#004A99"  # 設置填充顏色為藍色\nctx.rect(x + 320, y + 53, 60, 20)  # 定義矩形的左上角和寬高\nctx.fill()  # 填充矩形的顏色\n \n \n  利用 Brython 繪圖  \n', 'tags': '', 'url': 'w16_exam1.html'}, {'title': 'HW 3', 'text': '主題: Python 的數字、演算法與迴圈 (20%) \n Python 課程教材:  https://www.learnpythonwithjupyter.com/  - PART 4 and Part 5 \n 完成上述流程整理後, 請將 HW3 自評分數輸入 cp2024 自評表單中. \n \n', 'tags': '', 'url': 'HW 3.html'}, {'title': 'HW 3 Exam', 'text': '每六人為一組進行協同程式練習 \n 透過 Jupyterlab 協同網頁, 輪流指定各組編寫 HW 3 相關的程式練習, 以及網頁內容 (localhost 與 Codespaces 環境)編輯. \n', 'tags': '', 'url': 'HW 3 Exam.html'}, {'title': 'w16_exam2', 'text': '\n  導入 brython 程式庫  \n \n \n \n \n \n \n \n \n \n 程式學習收穫： \n 改進方向與延伸運用： \n \n \n 互動式迷宮： \n \n \n 添加用戶輸入功能，例如使用鍵盤方向鍵控制迷宮中的移動。 \n \n \n 在迷宮起點和終點設置指示點，用不同顏色或標誌表示，增強迷宮的互動性。 \n \n \n \n \n 自動生成迷宮： \n \n \n 實現一個算法（如深度優先搜索或Prim\'s Algorithm），動態生成迷宮路徑，避免手動編碼迷宮結構。 \n \n \n 將生成的迷宮數據存儲為陣列結構，然後根據數據繪製圖形。 \n \n \n \n \n 色彩與動態： \n \n \n 在迷宮中使用不同的顏色表示牆壁、路徑和探索進度。 \n \n \n 添加動畫效果，逐步展示迷宮的解路徑。 \n \n \n \n \n 擴展功能： \n \n \n 將迷宮保存為圖像文件（例如  .png ）。 \n \n \n 添加計時器，讓用戶挑戰解迷宮的速度。 \n \n \n 設置障礙或陷阱增加挑戰難度。 \n \n \n \n \n \n \n Canvas API 的應用：  深入學習  beginPath() 、 moveTo()  和  lineTo()  等核心方法，掌握如何控制圖形繪製過程。 \n \n \n 代碼可讀性提升：  系統性地添加註解，讓代碼不僅對自己而且對團隊成員更容易理解和修改。 \n \n \n 邏輯規劃：  將迷宮分段繪製，條理清晰，提升了程式設計的規劃能力。 \n \n \n \n sol: code \n Brython: code \n from browser import html\nfrom browser import document as doc\n\n# 創建 canvas 元素，並設置畫布的寬度和高度為 1000x250 像素\ncanvas = html.CANVAS(width=1000, height=250)\nbrython_div = doc["brython_div1"]  # 取得在 HTML 中 id 為 "brython_div1" 的元素\nbrython_div <= canvas  # 把 canvas 元素添加到指定的 div 中\n\n# 獲取 canvas 元素的 2D 渲染上下文 (context)，這樣就能在畫布上進行繪圖操作\nctx = canvas.getContext("2d")\n\n# 定義一個簡化的繪製直線的函數，這樣可以方便地多次使用\ndef draw_line(x1, y1, x2, y2, line_width=2, stroke_style="black"):\n    """\n    繪製一條直線，從 (x1, y1) 到 (x2, y2)，可設置線條寬度和顏色\n    """\n    ctx.lineWidth = line_width  # 設定線條的寬度\n    ctx.strokeStyle = stroke_style  # 設定線條的顏色\n    ctx.beginPath()  # 開始繪製路徑\n    ctx.moveTo(x1, y1)  # 把畫筆移動到起始點 (x1, y1)\n    ctx.lineTo(x2, y2)  # 繪製一條線條，從 (x1, y1) 到 (x2, y2)\n    ctx.stroke()  # 進行繪製，顯示線條\n\n# 定義一個繪製文本的函數\ndef draw_text(text, x, y, font="20px Arial", fill_style="black"):\n    """\n    在畫布上繪製文本，設置字體、顏色以及文本的位置\n    """\n    ctx.font = font  # 設置字體樣式\n    ctx.fillStyle = fill_style  # 設置文本顏色\n    ctx.fillText(text, x, y)  # 在 (x, y) 位置繪製文本\n\n# 繪製 L 形的線條，這是一個簡單的 L 形結構\ndef draw_l_shape(x, y):\n    """\n    繪製 L 形的兩條線條\n    第一條線從 (x, y) 到 (x + 300, y) — 水平線\n    第二條線從 (x, y) 到 (x, y + 300) — 垂直線\n    """\n    draw_line(x, y, x + 300, y)  # 繪製水平線\n    draw_line(x, y, x, y + 300)  # 繪製垂直線\n\n# 繪製紅色短線，這兩條短線用來強調指定的點\ndef draw_red_short_lines(x, y):\n    """\n    繪製兩條紅色的短線，用來標記 (x, y) 的位置\n    第一條是從 (x, y) 向下 1 像素的紅色短線\n    第二條是從 (x, y) 向右 1 像素的紅色短線\n    """\n    draw_line(x, y, x, y + 1, line_width=5, stroke_style="red")  # 繪製垂直的紅色短線\n    draw_line(x, y, x + 1, y, line_width=5, stroke_style="red")  # 繪製水平的紅色短線\n\n# 繪製藍色的六邊形多邊形\ndef draw_blue_polygon():\n    """\n    繪製一個由 6 條藍色線條組成的封閉多邊形\n    這個多邊形的每一條邊都是藍色的\n    """\n    # 各條邊的坐標順序\n    draw_line(130, 130, 170, 130, stroke_style="blue")  # 第一條邊\n    draw_line(190, 130, 230, 130, stroke_style="blue")  # 第二條邊\n    draw_line(230, 130, 230, 230, stroke_style="blue")  # 第三條邊\n    draw_line(230, 230, 190, 230, stroke_style="blue")  # 第四條邊\n    draw_line(170, 230, 130, 230, stroke_style="blue")  # 第五條邊\n    draw_line(130, 230, 130, 130, stroke_style="blue")  # 第六條邊\n\n# 繪製矩形內部的藍色線條，這些線條在矩形內部創建更多的小區域\ndef draw_inner_lines_in_rectangle():\n    """\n    繪製矩形內部的藍色線條，形成更多的小區域\n    """\n    # 這些線條是繪製在 (150, 150) 和 (210, 230) 之間的區域\n    draw_line(150, 150, 210, 150, stroke_style="blue")  # 上邊\n    draw_line(210, 150, 210, 170, stroke_style="blue")  # 右邊\n    draw_line(170, 150, 170, 170, stroke_style="blue")  # 中間的垂直線\n    draw_line(170, 170, 130, 170, stroke_style="blue")  # 下邊\n    draw_line(190, 170, 190, 190, stroke_style="blue")  # 內部短垂直線\n    draw_line(190, 190, 210, 190, stroke_style="blue")  # 內部短水平線\n    draw_line(210, 190, 210, 230, stroke_style="blue")  # 右邊\n    draw_line(170, 170, 150, 170, stroke_style="blue")  # 左邊\n    draw_line(150, 210, 150, 190, stroke_style="blue")  # 內部左邊\n    draw_line(150, 190, 190, 190, stroke_style="blue")  # 內部底部\n    draw_line(170, 230, 170, 210, stroke_style="blue")  # 內部右邊\n    draw_line(170, 210, 190, 210, stroke_style="blue")  # 內部右側底部\n\n# 主函數，負責調用所有繪圖函數來執行繪製操作\ndef main():\n    """\n    主函數，負責調用各種繪圖函數來完成圖形的繪製\n    """\n    # 繪製 L 形線條，起始位置為 (31, 42)\n    draw_l_shape(31, 42)\n\n    # 繪製紅色短線條，強調 (31, 42) 的位置\n    draw_red_short_lines(31, 42)\n\n    # 繪製文本 "(31,42)"，並將其放置在適當的 y 位置，避免與其他圖形重疊\n    draw_text("(31,42)", 40, 35, font="20px Arial", fill_style="red")\n\n    # 繪製藍色的多邊形\n    draw_blue_polygon()\n\n    # 繪製矩形內部的藍色線條，創建更多的小區域\n    draw_inner_lines_in_rectangle()\n\n# 調用主函數，執行所有繪圖操作\nmain() \n', 'tags': '', 'url': 'w16_exam2.html'}, {'title': 'HW 4', 'text': '主題: 利用 Python 控制機電模擬系統 (20%) \n 利用\xa0 https://solvespace.com/ \xa0建立機械系統零組件 \n 利用  CoppeliaSim  建立機電模擬系統 \n 利用  Python  跨網路控制瀏覽器上的機電模擬系統 \n 範例: \n cd2023_pj3ag4_zmq_football_4.7.7z \n cd2024_2b_g6_steel_ball_platform_nxopen_copsim.7z \n 完成上述流程整理後, 請將 HW4 自評分數輸入 cp2024 自評表單中. \n \n', 'tags': '', 'url': 'HW 4.html'}, {'title': 'HW 4 Exam', 'text': '每六人為一組進行協同程式練習 \n 透過 Jupyterlab 協同網頁, 輪流指定各組編寫 HW 4 相關的程式練習, 以及網頁內容 (localhost 與 Codespaces 環境)編輯. \n', 'tags': '', 'url': 'HW 4 Exam.html'}, {'title': 'w16_exam3', 'text': '一開始，我是透過ChatGPT了解如何繪製程式碼的功能和語法，接著自己進行計算並撰寫程式碼，尋找對應的色碼輸入，然後將程式碼上傳。這整個學期的過程，不僅讓我在課堂上學到了計算機程式的知識，也讓我學會了如何更有效地利用GPT來進行學習。我不再只是簡單地複製，而是透過不斷提問來解決理解上的問題，補足我的知識盲點，也改善了我的英文能力。GPT還能針對我不理解的地方進行加強說明，讓我在未來再次閱讀時，依然能夠理解。 \n \n \n 靈活使用 HTML Canvas API 透過  ctx.beginPath()  等 API，可以有效管理繪圖路徑並避免線條相互干擾。此外，運用  moveTo  和  lineTo  等方法，清晰地描述迷宮的各部分結構，讓繪製過程井然有序。 \n 模組化與參數化設計 在程式中利用變數（如  origin_x  和  origin_y ），可以輕鬆調整整體迷宮的位置偏移，讓繪圖更靈活。這種參數化的設計有助於後續維護及擴展。 \n 走迷宮邏輯的規劃 使用單獨的區塊繪製走迷宮路徑，將每一步都以簡單的線條指令表示，讓迷宮的解法可視化，直觀易懂。 \n 色彩與線條設置 運用  strokeStyle  和  lineWidth ，明確區分迷宮框架與解路徑，提升圖形的可讀性和視覺效果。 \n 程式結構的清晰性 透過明確的註解，對程式的每個部分進行詳細解釋，這不僅方便日後檢視，也利於其他開發者理解。 \n 學習與應用 Canvas API 的實踐 這次實現迷宮繪製的過程提供了全面操作 Canvas 的實踐機會，涵蓋了基本線條繪製、文字繪製、色彩管理等多方面內容。 \n 改進空間 \n \n 可以將迷宮的結構數據化，使用陣列或物件表示迷宮結構，進一步提高程式的可重用性。 \n 自動生成迷宮路徑，增強互動性與挑戰性。 \n 增加迷宮的動畫效果，讓視覺呈現更動態化。 \n \n \n \n \n sol: code \n Bython: code \n \n from browser import html\nfrom browser import document as doc\n\n# 創建 canvas 元素，並設置畫布的寬度和高度為 1000x300 像素\ncanvas = html.CANVAS(width=1000, height=300)\nbrython_div = doc["brython_div1"]  # 取得在 HTML 中 id 為 "brython_div1" 的元素\nbrython_div <= canvas  # 把 canvas 元素添加到指定的 div 中\n\n# 取得 canvas 元素的 2D 渲染上下文 (context)，這樣就能在畫布上進行繪圖操作\nctx = canvas.getContext("2d")\n\n# 定義一個簡化的繪製直線的函數，這樣可以方便地多次使用\ndef draw_line(x1, y1, x2, y2, line_width=2, stroke_style="black"):\n    """\n    繪製一條直線，從 (x1, y1) 到 (x2, y2)，可設定線條寬度和顏色\n    """\n    ctx.lineWidth = line_width  # 設定線條的寬度\n    ctx.strokeStyle = stroke_style  # 設定線條的顏色\n    ctx.beginPath()  # 開始繪製路徑\n    ctx.moveTo(x1, y1)  # 把畫筆移動到起始點 (x1, y1)\n    ctx.lineTo(x2, y2)  # 繪製一條線條，從 (x1, y1) 到 (x2, y2)\n    ctx.stroke()  # 進行繪製，顯示線條\n\n# 定義一個繪製文本的函數\ndef draw_text(text, x, y, font="20px Arial", fill_style="black"):\n    """\n    在畫布上繪製文本，設定字體、顏色以及文本的位置\n    """\n    ctx.font = font  # 設定字體樣式\n    ctx.fillStyle = fill_style  # 設定文本顏色\n    ctx.fillText(text, x, y)  # 在 (x, y) 位置繪製文本\n    ctx.font = "12px Arial"\n    ctx.fillStyle = "red"\n    ctx.fillText("入口", 170, 110)  # 在指定位置繪製“入口”字樣\n    ctx.fillText("出口", 170, 260)  # 在指定位置繪製“出口”字樣\n\n# 繪製紅色線條的函數\ndef draw_red_path():\n    """\n    繪製一條紅色路徑\n    """\n    # 繪製紅色路徑的每條線段\n    draw_line(180, 130, 180, 140, stroke_style="red")  # 繪製直線段\n    draw_line(180, 140, 220, 140, stroke_style="red")  # 繪製直線段\n    draw_line(220, 140, 220, 180, stroke_style="red")  # 繪製直線段\n    draw_line(220, 180, 200, 180, stroke_style="red")  # 繪製直線段\n    draw_line(200, 180, 200, 160, stroke_style="red")  # 繪製直線段\n    draw_line(200, 160, 180, 160, stroke_style="red")  # 繪製直線段\n    draw_line(180, 160, 180, 180, stroke_style="red")  # 繪製直線段\n    draw_line(180, 180, 140, 180, stroke_style="red")  # 繪製直線段\n    draw_line(140, 180, 140, 220, stroke_style="red")  # 繪製直線段\n    draw_line(140, 220, 160, 220, stroke_style="red")  # 繪製直線段\n    draw_line(160, 220, 160, 200, stroke_style="red")  # 繪製直線段\n    draw_line(160, 200, 200, 200, stroke_style="red")  # 繪製直線段\n    draw_line(200, 200, 200, 220, stroke_style="red")  # 繪製直線段\n    draw_line(200, 220, 180, 220, stroke_style="red")  # 繪製直線段\n    draw_line(180, 220, 180, 230, stroke_style="red")  # 繪製直線段\n\n# 繪製 L 形的線條，這是一條簡單的 L 形結構\ndef draw_l_shape(x, y):\n    """\n    繪製 L 形的兩條線條\n    第一條線從 (x, y) 到 (x + 300, y) — 水平線\n    第二條線從 (x, y) 到 (x, y + 300) — 垂直線\n    """\n    draw_line(x, y, x + 300, y)  # 繪製水平線\n    draw_line(x, y, x, y + 300)  # 繪製垂直線\n\n# 繪製紅色短線，這兩條短線用來強調指定的點\ndef draw_red_short_lines(x, y):\n    """\n    繪製兩條紅色的短線，用來標記 (x, y) 的位置\n    第一條是從 (x, y) 向下 1 像素的紅色短線\n    第二條是從 (x, y) 向右 1 像素的紅色短線\n    """\n    draw_line(x, y, x, y + 1, line_width=5, stroke_style="red")  # 繪製垂直的紅色短線\n    draw_line(x, y, x + 1, y, line_width=5, stroke_style="red")  # 繪製水平的紅色短線\n\n# 繪製藍色的六邊形多邊形\ndef draw_blue_polygon():\n    """\n    繪製一個由 6 條藍色線條組成的封閉多邊形\n    這個多邊形的每一條邊都是黑色的\n    """\n    # 各條邊的坐標順序\n    draw_line(130, 130, 170, 130, stroke_style="black")  # 第一條邊\n    draw_line(190, 130, 230, 130, stroke_style="black")  # 第二條邊\n    draw_line(230, 130, 230, 230, stroke_style="black")  # 第三條邊\n    draw_line(230, 230, 190, 230, stroke_style="black")  # 第四條邊\n    draw_line(170, 230, 130, 230, stroke_style="black")  # 第五條邊\n    draw_line(130, 230, 130, 130, stroke_style="black")  # 第六條邊\n\n# 繪製矩形內部的藍色線條，這些線條在矩形內部創建更多的小區域\ndef draw_inner_lines_in_rectangle():\n    """\n    繪製矩形內部的藍色線條，形成更多的小區域\n    """\n    # 這些線條是繪製在 (150, 150) 和 (210, 230) 之間的區域\n    draw_line(150, 150, 210, 150, stroke_style="black")  # 上邊\n    draw_line(210, 150, 210, 170, stroke_style="black")  # 右邊\n    draw_line(170, 150, 170, 170, stroke_style="black")  # 中間的垂直線\n    draw_line(170, 170, 130, 170, stroke_style="black")  # 下邊\n    draw_line(190, 170, 190, 190, stroke_style="black")  # 內部短垂直線\n    draw_line(190, 190, 210, 190, stroke_style="black")  # 內部短水平線\n    draw_line(210, 190, 210, 230, stroke_style="black")  # 右邊\n    draw_line(170, 170, 150, 170, stroke_style="black")  # 左邊\n    draw_line(150, 210, 150, 190, stroke_style="black")  # 內部左邊\n    draw_line(150, 190, 190, 190, stroke_style="black")  # 內部底部\n    draw_line(170, 230, 170, 210, stroke_style="black")  # 內部右邊\n    draw_line(170, 210, 190, 210, stroke_style="black")  # 內部右側底部\n\n# 主函數，負責調用所有繪圖函數來執行繪製操作\ndef main():\n    """\n    主函數，負責調用各種繪圖函數來完成圖形的繪製\n    """\n    # 繪製 L 形線條，起始位置為 (31, 42)\n    draw_l_shape(31, 42)\n\n    # 繪製紅色短線條，強調 (31, 42) 的位置\n    draw_red_short_lines(31, 42)\n\n    # 繪製文本 "(31,42)"，並將其放置在適當的 y 位置，避免與其他圖形重疊\n    draw_text("(31,42)", 40, 35, font="20px Arial", fill_style="red")\n\n    # 繪製紅色路徑\n    draw_red_path()\n\n    # 繪製藍色的多邊形\n    draw_blue_polygon()\n\n    # 繪製矩形內部的藍色線條，創建更多的小區域\n    draw_inner_lines_in_rectangle()\n\n# 調用主函數，執行所有繪圖操作\nmain()', 'tags': '', 'url': 'w16_exam3.html'}, {'title': 'Final Report', 'text': '期末口頭與書面專題報告 (20%) \n 期末口頭專題報告影片: \n ...... \n 期末書面專題報告檔案 (pdf): \n ...... \n 電腦輔助設計與實習課程總結心得: \n ...... \n 期末報告自評成績: \n 完成上述流程後, 請將 Final Report 自評分數輸入 cp2024 自評表單中. \n', 'tags': '', 'url': 'Final Report.html'}, {'title': 'Brython', 'text': '從 1 累加到 100: \n 1 add to 100 \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從 1 累加到 100 part2: \n 1 add to 100 cango_three_gears BSnake AI Tetris Rotating Block \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n \n \n', 'tags': '', 'url': 'Brython.html'}]};