var tipuesearch = {"pages": [{'title': 'About', 'text': '國立虎尾科技大學機械設計工程系 \n National Formosa University \n Department of Mechanical Design Engineering \n cp2024 計算機程式 \n 課程教材: \n Learn Python with Jupyter  ( site ,  ebook ) \n 教育版帳號\xa0microsoftonline 登入點:\xa0 https://login.microsoftonline.com/ \n Teams 線上教學: \n 以 "學號@nfu.edu.tw" 登入  https://login.microsoftonline.com/  Office 365 \n Teams 團隊代碼:  ldodwua \n 個人倉儲:  https://github.com/mdecp2024/hw-SKYang41323142 \n 個人網站:  https://mde.tw/cp2024/content/index.html\xa0 \n 其他資訊: \n cd2023_pj3ag4_zmq_football_4.7.7z \n cd2024_2b_g6_steel_ball_platform_nxopen_copsim.7z \n https://animated-fiesta-6949rp7w4vw7hxvqx-8081.app.github.dev/content/index.html \n', 'tags': '', 'url': 'About.html'}, {'title': 'Attendance', 'text': '出席 (10%) - 自行舉證評分 \n 自行利用 Github commits 提交記錄評分. \n', 'tags': '', 'url': 'Attendance.html'}, {'title': 'HW 1', 'text': '主題: 基於瀏覽器的分散式版次管理與整合程式開發環境 (10%) \n USB 隨身碟: \n 下載  python_2025_lite.7z  (428 MB, 解開壓縮後約 1.5 GB) \n Jupyter \n What are Github and Codespaces? \n Hello World - GitHub Docs \n 利用包含學號的字串作為帳號, 申請免費使用 Github. \n Python 課程教材:  https://www.learnpythonwithjupyter.com/  - PART 1 \n \n PART 1: Creating the basics 資料整理 (10%) \n 啟動可攜程式系統後, 在命令列中: \n y:\\>cd notebook \n y:\\notebook>jupyter lab --collaborative \n 進入  01_string_input_print.ipynb  練習如何修改 PART1 notebook 後存檔, 上傳至作業倉儲中的 downloads 目錄後, 透過  https://nbviewer.org/  將已經提交的  01_string_input_print.ipynb , 嵌入下列網頁中. \n \n 上列 iframe 標註的 html 語法: \n <iframe width="600" height="400" src="https://nbviewer.org/urls/mde.tw/cp2024_hw/downloads/01_string_input_print.ipynb"></iframe> \n 完成上述流程整理後, 請將 HW1 自評分數輸入 cp2024 自評表單中. \n', 'tags': '', 'url': 'HW 1.html'}, {'title': 'HW 1 Exam', 'text': '每六人為一組進行協同程式練習 \n 透過 Jupyterlab 協同網頁, 輪流指定各組編寫 Topic 1 相關的程式練習, 以及網頁內容 (localhost 與 Codespaces 環境)編輯. \n', 'tags': '', 'url': 'HW 1 Exam.html'}, {'title': 'w7', 'text': '\n', 'tags': '', 'url': 'w7.html'}, {'title': 'w10', 'text': '\xa0題目一 \n \n 題目二 \n \n 題目三 \n \n', 'tags': '', 'url': 'w10.html'}, {'title': 'w11', 'text': '1.\xa0 已知可以用 Python 程式 由上往下列印三角形 * , 或 由左往右列印三角形 * , 請將此程式延伸到可以在 10x10 的字元區域中, 以 "*" 字元列印出圓型區域. 完成後請將程式碼存入個人 Gist 後, 直接在個人作業網站中的 Brython 頁面中執行. (提示: ?src=gist_script_URL) \n 2. 已知可以在網頁中利用 Brython 繪製方格與塗色, 如下連結, 請設法修改此一程式, 直接將程式存入個人的 Gist, 並利用黑色方塊圍出一個圓形區域. \n 網頁上的方格與塗色 \n 3. 完成上列題目後, 請利用 Youtube 影片 簡報 個人的解題過程與心得. \n', 'tags': '', 'url': 'w11.html'}, {'title': 'w11_hw', 'text': '1.\xa0 已知可以用 Python 程式 由上往下列印三角形 * , 或 由左往右列印三角形 * , 請將此程式延伸到可以在 10x10 的字元區域中, 以 "*" 字元列印出圓型區域. 完成後請將程式碼存入個人 Gist 後, 直接在個人作業網站中的 Brython 頁面中執行. (提示: ?src=gist_script_URL) \n 2. 已知可以在網頁中利用 Brython 繪製方格與塗色, 如下連結, 請設法修改此一程式, 直接將程式存入個人的 Gist, 並利用黑色方塊圍出一個圓形區域. \n 網頁上的方格與塗色 \n 3. 完成上列題目後, 請利用 Youtube 影片 簡報 個人的解題過程與心得. \n 1.在 10x10 的字元區域中, 以 "*" 字元列印出圓型區域 (Gist) \n code: \n # 定義區域大小\nwidth = 41  # 橫向大小（更高解析度）\nheight = 21  # 縱向大小\n\n# 圓心位置\ncenter_x = width // 2  # 圓心 x 坐標，取寬度的一半\ncenter_y = height // 2  # 圓心 y 坐標，取高度的一半\n\n# 圓的半徑\nradius = 10  # 圓的半徑長度\n\n# 縱向縮放比例\nvertical_scale = 2.2  # 修正字元比例，使圓形看起來更接近真圓\n\n# 繪製圓形\nfor y in range(height):  # 遍歷每一行\n    for x in range(width):  # 遍歷每一列\n        # 計算每個點與圓心的距離\n        dx = x - center_x  # x 軸距離\n        dy = (y - center_y) * vertical_scale  # y 軸距離，乘以縱向縮放比例\n        distance_squared = dx ** 2 + dy ** 2  # 計算與圓心的平方距離\n        \n        # 使用不同字符根據距離漸變\n        if distance_squared <= radius ** 2:  # 判斷是否在圓的範圍內\n            if distance_squared > (radius - 1) ** 2:  # 判斷是否在邊界區域\n                print(".", end="")  # 邊界區域用 "."\n            else:\n                print("*", end="")  # 圓內區域用 "*"\n        else:\n            print(" ", end="")  # 圓外區域留空\n    print()  # 換行，開始下一行繪製 \n \n \n 2.使用 Brython\xa0圍出圓形方格區域 (Gist) \n code : \n from browser import html  # 引入 html 模組，用於建立 DOM 元素\nfrom browser import document as doc  # 引入 document，操作網頁內容\n\n# 利用 html 建立 canvas 超文件物件\ncanvas = html.CANVAS(width=400, height=400)  # 建立一個 400x400 的畫布\nbrython_div = doc["brython_div1"]  # 取得網頁中 id 為 brython_div1 的元素\nbrython_div <= canvas  # 將畫布加入到網頁中指定的 div 元素中\n\n# 每一格的 pixel 數\ngs = 20  # 定義每個網格的像素大小為 20px\n\n# canvas 的上下文\nctx = canvas.getContext("2d")  # 獲取 2D 繪圖上下文，進行繪圖操作\n\ndef dRect(lux, luy, w, h, s=1, c="lightgrey"):\n    """繪製網格框"""\n    ctx.lineWidth = s  # 設定框線寬度\n    ctx.strokeStyle = c  # 設定框線顏色\n    ctx.beginPath()  # 開始繪製路徑\n    ctx.rect(lux, luy, w, h)  # 繪製矩形，左上角座標 (lux, luy)，寬 w，高 h\n    ctx.stroke()  # 描繪路徑\n\ndef grid(width, height, grid_pix):\n    """繪製網格"""\n    for i in range(width):  # 遍歷每一列\n        for j in range(height):  # 遍歷每一行\n            dRect(i * grid_pix, j * grid_pix, grid_pix, grid_pix, 1, "lightgrey")  # 繪製單個網格框\n\ndef fill(x, y, color):\n    """填充顏色"""\n    ctx.fillStyle = color  # 設定填充顏色\n    ctx.fillRect(x * gs, y * gs, gs, gs)  # 填充矩形，位置 (x, y)，大小為 gs x gs\n\n# 繪製網格\ngrid(11, 11, gs)  # 繪製 11x11 的網格，每格大小為 gs\n\n# 定義圓的參數\nwidth, height = 11, 11  # 圖形範圍的寬與高（以網格單位表示）\ncenter_x, center_y = 5, 5  # 圓心座標（以網格單位表示）\nradius = 5  # 圓的半徑（以網格單位表示）\n\n# 填充圓形內部區域\nfor y in range(height):  # 遍歷每一行\n    for x in range(width):  # 遍歷每一列\n        # 計算點到圓心的距離\n        distance = ((x - center_x) ** 2 + (y - center_y) ** 2) ** 0.5  # 使用歐幾里得距離公式\n        if distance <= radius:  # 判斷是否在圓的範圍內\n            fill(x, y, "black")  # 在符合條件的點填充黑色 \n 邏輯說明 \n \n 修改 Brython 程式，根據圓的公式判斷每個方格是否位於圓形區域內。 \n 使用黑色塊填充圓形的方格。 \n \n \n', 'tags': '', 'url': 'w11_hw.html'}, {'title': 'w12_hw', 'text': '1. 請各組組員分別利用  Brython 以及 Jupyter lab  環境, 執行 可攜程式  notebook 目錄中的  01_string_input_print.ipynb 至\xa010_for_search.ipynb  筆記本程式, 完成後請將能在 Brython 執行的程式碼存入個人  Gist  後, 將各程式執行連結放入 w12_hw 網頁上. 最後請說明各範例中所使用的程式語法以及執行心得. \n 1.for迴圈跟print的範例程式 \n code  :\xa0 \n # 定義一個清單 \n fruits = ["蘋果", "香蕉", "橘子", "芒果"] \n # 用 for 迴圈列印每個水果 for fruit in fruits:  print(f"我最喜歡的水果之一是: {fruit}") \n My gist :  for迴圈跟print的範例程式 \n \n 執行心得 \n \n \n 學到的概念 \n \n for  迴圈的便利性：可以用於處理範圍內的數字或列表等集合資料。 \n 配合條件判斷後，可以輕鬆篩選數據或進行分類。 \n 使用  f-string  增強輸出的可讀性，讓結果更清楚。 \n \n \n \n 遇到的問題 \n \n 問題 ：剛開始不熟悉  range()  的起始與結束值。\n \n 解釋： range(start, end)  包含起始值但不包含結束值，因此需注意範圍邊界。 \n \n \n 解決方法 ：多次嘗試不同的範圍設置，熟悉  range()  的運作方式。 \n \n \n \n 2. for  迴圈與字串操作的範例程式 \n code  :\xa0 \n # 定義一個字串 text = "Hello, World!" \n # 使用 for 迴圈遍歷字串中的每個字元 for char in text:  print(f"字元: {char}") \n My gist :  for 迴圈與字串操作的範例程式 \n \n \n 執行心得 \n \n \n 學到的概念 \n \n 字串本質上是一個字元的集合，能夠像列表一樣進行遍歷。 \n 使用  for  迴圈結合  print() ，可以輕鬆觀察每個字元的內容。 \n \n \n \n', 'tags': '', 'url': 'w12_hw.html'}, {'title': 'w13_hw', 'text': 'My gist :  最終程式 \n 解題思考: 透過點座標的掃瞄, 先採用尺寸較大格點 (如每 10 pixel 掃描一點), 即可判定點群位於那一個特定區域並進行著色. 當掃描細至單一 pixel 時, 就可以完成區域著色. \n 另外, 透過 if 判定各點所在區域的條件組合, 可以就是否: \n 位於第一個圓內部 \n 位於第二個圓內部 \n 位於第一個正方形內部 \n 位於第二個正方形內部第一個正方形上方、下方、左方、右方 \n 位於第二個正方形上方、下方、左方、右方 \n 位於對角線上方範圍 \n 位於對角線下方範圍 \n 等條件 區分各區域的不同屬性 , 並設法利用這些區域屬性進行 顏色運算 . \n 接近正確 以及 更細化 的著色範例. \n rect_fill_1 \n rect_fill_2 \n  導入 brython 程式庫  \n \n \n  啟動 Brython  \n \n  畫布定位點  \n \n  利用 Brython 繪圖  \n \n code: \n <script type="text/python">// <![CDATA[\nfrom browser import html  # 匯入 HTML 元素模組\nfrom browser import document as doc  # 匯入文件操作模組\nimport math  # 匯入數學模組，用於計算圓弧\nimport random  # 匯入隨機模組，用於生成隨機顏色\n\n# 建立畫布\ncanvas = html.CANVAS(width=500, height=500)  # 建立一個 500x500px 的畫布\nbrython_div = doc["brython_div1"]  # 獲取 HTML 中 id 為 brython_div1 的 div\nbrython_div <= canvas  # 將畫布插入到指定的 div 中\nctx = canvas.getContext("2d")  # 獲取 2D 繪圖上下文\nctx.lineWidth = 4  # 設定筆觸寬度\n\n# 隨機顏色函數\ndef random_color():\n    return f"rgb({random.randint(0, 255)}, {random.randint(0, 255)}, {random.randint(0, 255)})" \n    # 返回隨機生成的 RGB 顏色\n\n# 畫布背景\nctx.fillStyle = "white"  # 設定背景顏色為白色\nctx.fillRect(0, 0, 500, 500)  # 填滿畫布\n\n# 畫分段圓形\ndef draw_segmented_circle(x, y, radius, segments):\n    """繪製分段圓形"""\n    for i in range(segments):  # 根據分段數量繪製多個圓弧\n        start_angle = (i / segments) * 2 * math.pi  # 計算起始角度\n        end_angle = ((i + 1) / segments) * 2 * math.pi  # 計算結束角度\n        ctx.beginPath()  # 開始繪製路徑\n        ctx.arc(x, y, radius, start_angle, end_angle)  # 繪製圓弧\n        ctx.lineTo(x, y)  # 連線到圓心\n        ctx.closePath()  # 封閉路徑\n        ctx.fillStyle = random_color()  # 設定填充顏色為隨機顏色\n        ctx.fill()  # 填充路徑\n        ctx.strokeStyle = "black"  # 設定邊框顏色為黑色\n        ctx.stroke()  # 繪製邊框\n\n# 畫三角形\ndef draw_triangle(vertices, color="red"):\n    """繪製三角形"""\n    ctx.beginPath()  # 開始繪製路徑\n    ctx.moveTo(*vertices[0])  # 移動到第一個頂點\n    for vertex in vertices[1:]:  # 遍歷剩餘頂點\n        ctx.lineTo(*vertex)  # 繪製邊\n    ctx.closePath()  # 封閉路徑\n    ctx.fillStyle = color  # 設定填充顏色\n    ctx.fill()  # 填充三角形\n    ctx.strokeStyle = "black"  # 設定邊框顏色為黑色\n    ctx.stroke()  # 繪製邊框\n\n# 畫斜線\ndef draw_line(start, end, color="blue"):\n    """繪製直線"""\n    ctx.strokeStyle = color  # 設定線條顏色\n    ctx.beginPath()  # 開始繪製路徑\n    ctx.moveTo(*start)  # 移動到起點\n    ctx.lineTo(*end)  # 繪製到終點\n    ctx.stroke()  # 繪製線條\n\n# 繪製內容\ndraw_segmented_circle(160, 160, 100, 6)  # 繪製第一個分段圓，中心在 (160, 160)\ndraw_segmented_circle(300, 300, 100, 6)  # 繪製第二個分段圓，中心在 (300, 300)\n\n# 繪製三角形區域\ndraw_triangle([(50, 50), (50, 250), (250, 250)], random_color())  # 第一個三角形\ndraw_triangle([(150, 150), (350, 150), (350, 350)], random_color())  # 第二個三角形\n\n# 繪製藍色斜線\ndraw_line((50, 50), (250, 250))  # 繪製從 (50, 50) 到 (250, 250) 的斜線\n// ]]>\n \n \n', 'tags': '', 'url': 'w13_hw.html'}, {'title': 'w14_hw', 'text': 'My gist : 最終程式 \n 根據兩個圓繪圖所圍成的 區域 (目前圍成三個區域, 但若圓心移動可能彼此獨立)進行不同顏色著色, 條件是當各圓半徑與圓心座標變動時, 程式只需輸入兩個圓的圓心座標與半徑, 就可以完成各區域的著色任務. \n  導入 Brython 程式庫  \n \n \n \n \n \n  畫布定位點  \n \n  利用 Brython 繪圖  \n \n \n code: \n from browser import html  # 匯入 html 模組，用於建立網頁中的 HTML 元素\nfrom browser import document as doc  # 匯入 document 模組，方便操作 DOM\nimport random  # 匯入 random 模組，用於生成隨機數\nimport math  # 匯入 math 模組，用於數學計算\n\n# 初始化畫布的函式\ndef initialize_canvas(canvas_width=400, canvas_height=400, id="brython_div1"):\n    canvas = html.CANVAS(width=canvas_width, height=canvas_height)  # 建立指定大小的畫布元素\n    brython_div = doc[id]  # 找到網頁中 id 為指定名稱的元素\n    brython_div <= canvas  # 將畫布元素添加到網頁中\n    ctx = canvas.getContext("2d")  # 獲取 2D 繪圖上下文\n    return canvas, ctx  # 返回畫布與上下文\n\n# 生成隨機顏色\ndef random_color_generator():\n    r = random.randint(0, 255)  # 隨機生成 0-255 的紅色值\n    g = random.randint(0, 255)  # 隨機生成 0-255 的綠色值\n    b = random.randint(0, 255)  # 隨機生成 0-255 的藍色值\n    return f"rgb({r}, {g}, {b})"  # 返回 RGB 顏色格式的字串\n\n# 判斷點是否在圓內\ndef is_point_in_circle(px, py, cx, cy, r):\n    return (px - cx) ** 2 + (py - cy) ** 2 <= r ** 2  # 計算點到圓心的平方距離，判斷是否小於等於半徑的平方\n\n# 繪製三個圓的區域塗色\ndef draw_three_circles(x1, y1, r1, x2, y2, r2, x3, y3, r3):\n    canvas, ctx = initialize_canvas(400, 400)  # 初始化畫布與繪圖上下文\n    ctx.clearRect(0, 0, canvas.width, canvas.height)  # 清空畫布\n    # 定義不同區域的顏色\n    color_dict = {}  # 用於儲存每個區域的顏色\n    for py in range(0, canvas.height):  # 遍歷畫布每一行像素\n        for px in range(0, canvas.width):  # 遍歷畫布每一列像素\n            # 判斷點是否在每個圓內\n            in_circle1 = is_point_in_circle(px, py, x1, y1, r1)  # 判斷點是否在第一個圓內\n            in_circle2 = is_point_in_circle(px, py, x2, y2, r2)  # 判斷點是否在第二個圓內\n            in_circle3 = is_point_in_circle(px, py, x3, y3, r3)  # 判斷點是否在第三個圓內\n            # 判斷區域類型\n            if in_circle1 and in_circle2 and in_circle3:  # 如果點在三個圓的交集區域內\n                if "intersection_all" not in color_dict:  # 若尚未為該區域定義顏色\n                    color_dict["intersection_all"] = random_color_generator()  # 為該區域生成顏色\n                current_color = color_dict["intersection_all"]  # 使用該區域的顏色\n            elif in_circle1 and in_circle2:  # 如果點在第一、第二圓的交集區域內\n                if "intersection_1_2" not in color_dict:  # 若尚未為該區域定義顏色\n                    color_dict["intersection_1_2"] = random_color_generator()  # 為該區域生成顏色\n                current_color = color_dict["intersection_1_2"]  # 使用該區域的顏色\n            elif in_circle1 and in_circle3:  # 如果點在第一、第三圓的交集區域內\n                if "intersection_1_3" not in color_dict:  # 若尚未為該區域定義顏色\n                    color_dict["intersection_1_3"] = random_color_generator()  # 為該區域生成顏色\n                current_color = color_dict["intersection_1_3"]  # 使用該區域的顏色\n            elif in_circle2 and in_circle3:  # 如果點在第二、第三圓的交集區域內\n                if "intersection_2_3" not in color_dict:  # 若尚未為該區域定義顏色\n                    color_dict["intersection_2_3"] = random_color_generator()  # 為該區域生成顏色\n                current_color = color_dict["intersection_2_3"]  # 使用該區域的顏色\n            elif in_circle1:  # 如果點僅在第一個圓內\n                if "circle1" not in color_dict:  # 若尚未為該區域定義顏色\n                    color_dict["circle1"] = random_color_generator()  # 為該區域生成顏色\n                current_color = color_dict["circle1"]  # 使用該區域的顏色\n            elif in_circle2:  # 如果點僅在第二個圓內\n                if "circle2" not in color_dict:  # 若尚未為該區域定義顏色\n                    color_dict["circle2"] = random_color_generator()  # 為該區域生成顏色\n                current_color = color_dict["circle2"]  # 使用該區域的顏色\n            elif in_circle3:  # 如果點僅在第三個圓內\n                if "circle3" not in color_dict:  # 若尚未為該區域定義顏色\n                    color_dict["circle3"] = random_color_generator()  # 為該區域生成顏色\n                current_color = color_dict["circle3"]  # 使用該區域的顏色\n            else:\n                current_color = "white"  # 如果點不在任何圓內，填充背景色\n            # 填充當前像素\n            ctx.fillStyle = current_color  # 設定填充顏色\n            ctx.fillRect(px, py, 1, 1)  # 填充 1x1 像素大小的矩形\n\n# 測試參數\nx1, y1, r1 = 150, 200, 100  # 第一個圓的圓心與半徑\nx2, y2, r2 = 250, 200, 100  # 第二個圓的圓心與半徑\nx3, y3, r3 = 200, 300, 100  # 第三個圓的圓心與半徑\n\n# 繪製三個圓的區域塗色\ndraw_three_circles(x1, y1, r1, x2, y2, r2, x3, y3, r3)  # 調用函式進行繪製\n \n \n', 'tags': '', 'url': 'w14_hw.html'}, {'title': 'w15', 'text': '題目一: \n 請利用 Gist 與 Brython 程式環境, 在個人的課程網站中新增一個頁面, 標題為 w15, 以" 從 1 累加到 100 "作為 anchor 的連結標題, 使用者點擊該連結之後, 可從各自的 Brython 頁面執行程式. \n # 初始化變數 sum，用來累計總和，初始值設為 0\nsum = 0\n\n# 使用 for 迴圈，從 0 遍歷到 100（包含 100）\nfor i in range(0, 101):  # range(0, 101) 會產生從 0 到 100 的整數序列\n    sum += i  # 將當前的數字 i 累加到 sum 中\n\n# 輸出最終累加的結果\nprint(sum)  # 輸出結果：5050 \n 題目二: \n 延伸上題, 設計一個函式  addto(1, 100) , 可以完成上述的累加結果. (以" addto "作為連結標題) \n def addto(start, end):\n    """\n    計算從 start 到 end 之間所有整數的總和。\n      \n    參數：\n    start: 開始的整數\n    end: 結束的整數（包含在內）\n  \n    返回：\n    整數總和\n    """\n    sum = 0  # 初始化總和為 0\n    for i in range(start, end + 1):  # 使用 for 迴圈，從 start 遍歷到 end（包括 end）\n        sum += i  # 將當前數字 i 加入總和 sum\n    return sum  # 返回計算的總和\n  \n# 測試函式\nresult = addto(1, 100)  # 調用 addto 函式，計算從 1 到 100 的總和\nprint(result)  # 使用 print 輸出函式的返回值\n \n 題目三: \n 延伸上題, 設計一個函式  add_only_even(1, 100) , 可以完成從第一個輸入整數, 累加到第二個輸入變數的累加結果. 頁面中請以  add_only_even \xa0作為連結標題. \n def addto(start, end):\n    """\n    計算從 start 到 end 之間所有整數的總和。\n      \n    參數：\n    start: 開始的整數\n    end: 結束的整數（包含在內）\n  \n    返回：\n    整數總和\n    """\n    sum = 0  # 初始化總和為 0\n    for i in range(start, end + 1):  # 從 start 累加到 end，包含 end\n        sum += i  # 將當前數字加入總和\n    return sum  # 返回計算的總和\n  \n# 測試函式\n    result = addto(1, 100)  # 計算 1 到 100 的總和\n    print(result)  # 輸出結果 \n 題目四:  \n 延伸上題, 設計一個函式  add_avoid_8 (1, 100), 可以完成從第一個輸入整數, 累加到第二個輸入變數的累加過程, 必須避開數字出現"8"的整數,\xa0頁面中請以  add_avoid_8  作為連結標題. \n # 定義 add_avoid_8 函式，接受兩個參數 start 和 end\ndef add_avoid_8(start, end):\n    """\n    計算從 start 到 end（包含 end）之間所有不包含數字 \'8\' 的數字總和\n    """\n    total_sum = 0  # 初始化總和為 0\n    # 遍歷從 start 到 end 之間的所有數字\n    for i in range(start, end + 1):  # 從 start 開始迴圈到 end，包含 end\n        # 將數字轉換為字符串並檢查是否包含 \'8\'\n        if \'8\' not in str(i):  # 如果 \'8\' 沒有出現在該數字的字符串表示中\n            total_sum += i  # 將當前數字加入總和\n    return total_sum  # 返回最終的累加和\n \n# 呼叫 add_avoid_8 函式，計算從 1 到 100 之間不包含數字 \'8\' 的數字總和\nresult = add_avoid_8(1, 100)  # 計算結果儲存到 result 變數中\n \n# 輸出結果\nprint(result)  # 輸出 result 變數的值\n \n 延伸第四題： add_avoid_8_and_3 (1 , 100 ) \n # 定義 add_avoid_8_and_3 函式，接受兩個參數 start 和 end\ndef add_avoid_8_and_3(start, end):\n    """\n    計算從 start 到 end（包含 end）之間所有不包含數字 \'8\' 或 \'3\' 的數字總和\n    """\n    total_sum = 0  # 初始化總和為 0\n    # 遍歷從 start 到 end 之間的所有數字\n    for i in range(start, end + 1):  # 使用 for 迴圈，從 start 遍歷到 end（包含 end）\n        # 將數字轉換為字符串並檢查是否包含 \'8\' 或 \'3\'\n        if \'8\' not in str(i) and \'3\' not in str(i):  # 如果數字中不包含 \'8\' 和 \'3\'\n            total_sum += i  # 將當前數字加到總和中\n    return total_sum  # 返回計算的總和\n \n# 呼叫 add_avoid_8_and_3 函式，計算從 1 到 100 之間不包含數字 \'8\' 或 \'3\' 的數字總和\nresult = add_avoid_8_and_3(1, 100)  # 將結果儲存到 result 變數中\n \n# 輸出結果\nprint(result)  # 輸出 result 的值\n \n 心得與收穫 \n \n 使用 Brython 的動態特性可以快速生成互動式網頁。 \n 函式化設計讓程式易於擴展，例如新增其他累加規則。 \n HTML 與 Brython 的結合提高了程式的可讀性與可操作性。 \n 理解了如何使用條件篩選與 Python 的字串操作來實現複雜功能。 \n \n \n  利用 Brython 繪圖  \n \n \n', 'tags': '', 'url': 'w15.html'}, {'title': 'HW 2', 'text': '主題: Python 的數列、判斷式與重複迴圈 (20%) \n Python 課程教材:  https://www.learnpythonwithjupyter.com/  - PART 2 and Part 3 \n \n 延續 HW 1 網頁資料整理與程式練習方法, 整理下列內容 (20%): \n PART 2: Introduction to lists and if/else statements \n PART 3: Introduction to the for loop \n 完成上述流程整理後, 請將 HW2 自評分數輸入 cp2024 自評表單中. \n', 'tags': '', 'url': 'HW 2.html'}, {'title': 'HW 2 Exam', 'text': '每六人為一組進行協同程式練習 \n 透過 Jupyterlab 協同網頁, 輪流指定各組編寫 HW 2 相關的程式練習, 以及網頁內容 (localhost 與 Codespaces 環境)編輯. \n', 'tags': '', 'url': 'HW 2 Exam.html'}, {'title': 'w16_exam1', 'text': '\n Brython Canvas Demo \n \n  畫布容器  \n \n  Brython 程式碼  \n \n 結構化設計 代碼結構清晰，層次分明，每段程式碼都專注於實現特定的圖形繪製功能，有助於後續的維護和修改。 透過使用 offset_x 和 offset_y，讓圖形定位以基準點為參考，使得排列與重新調整更加直觀與簡單。 多樣化形狀 示範了利用 Canvas API 繪製多種類型的幾何圖形，包括六邊形、菱形、三角形和圓形等。 使用鮮明的色彩區分不同形狀，進一步提升了視覺效果。 座標系統應用 通過繪製 X、Y 軸並標記原點，提供了明確的參考框架，方便後續進行圖形定位與設計調整。 \n sol: code \n Brython: code \n \n  導入 Brython 程式庫  \n \n \n  啟動 Brython  \n \n  畫布定位點  \n \n from browser import html  # 匯入 Brython 的 html 模組，用於操作 HTML 元素\nfrom browser import document as doc  # 匯入 Brython 的 document 物件，操作網頁中的 DOM\n\n# 創建畫布 (canvas)，並設置其大小為 2000x150 像素\ncanvas = html.CANVAS(width=2000, height=150)\n# 取得 HTML 中 id 為 brython_div1 的元素，這樣可以把畫布放置到這個元素中\nbrython_div = doc["brython_div1"]\n# 將畫布添加到 HTML 頁面中的指定元素中\nbrython_div <= canvas\n\n# 取得畫布的 2D 繪圖上下文，這樣我們才能在畫布上繪製圖形\nctx = canvas.getContext("2d")\n\n# 設置畫筆的寬度為 2 像素，這樣我們畫的線會較粗\nctx.lineWidth = 2\n# 設置畫筆的顏色為黑色\nctx.strokeStyle = "black"\n\n# 繪製 X 軸 (從原點 (31, 42) 向右延伸到 (88, 42))\nctx.beginPath()  # 開始繪製新的路徑\nctx.moveTo(31, 42)  # 將畫筆移動到 X 軸起始點 (31, 42)\nctx.lineTo(88, 42)  # 畫一條線到 X 軸終點 (88, 42)\nctx.stroke()  # 完成繪製並顯示這條線\n\n# 繪製 Y 軸 (從原點 (31, 42) 向下延伸到 (31, 134))\nctx.beginPath()  # 開始繪製新的路徑\nctx.moveTo(31, 42)  # 將畫筆移動到 Y 軸起始點 (31, 42)\nctx.lineTo(31, 134)  # 畫一條線到 Y 軸終點 (31, 134)\nctx.stroke()  # 完成繪製並顯示這條線\n\n# 設置字體樣式為 20px 的 Arial 字型，並設置文字顏色為黑色\nctx.font = "20px Arial"  # 設定字型為 Arial，大小為 20px\nctx.fillStyle = "black"  # 設定填充文字的顏色為黑色\n\n# 在畫布上 (90, 64) 位置添加文字 "+X"\nctx.fillText("+X", 90, 64)  # 在 X 軸正方向添加標籤 "+X"\n\n# 在畫布上 (20, 150) 位置添加文字 "+Y"\nctx.fillText("+Y", 20, 150)  # 在 Y 軸正方向添加標籤 "+Y"\n\n# 更改字體樣式為 12px 的 Arial 字型，用來標示原點座標\nctx.font = "12px Arial"  # 設定字型為 Arial，大小為 12px\nctx.fillStyle = "black"  # 設定填充文字的顏色為黑色\n# 在 (35, 59) 位置顯示文字 "(31, 42)"\nctx.fillText("(31, 42)", 35, 59)  # 在原點旁邊顯示座標 "(31, 42)"\n\n# 設置位移偏移量，x 和 y 變數對應新原點座標 (31, 42)\nx = 31  # 定義 x 為原點的 X 座標\ny = 42  # 定義 y 為原點的 Y 座標\n\n# 繪製橙色六邊形\nctx.beginPath()  # 開始繪製六邊形\nctx.fillStyle = "#EBB000"  # 設置填充顏色為橙色\nctx.moveTo(x + 40, y + 70)  # 六邊形的第一個頂點\nctx.lineTo(x + 60, y + 40)  # 第二個頂點\nctx.lineTo(x + 90, y + 40)  # 第三個頂點\nctx.lineTo(x + 110, y + 70)  # 第四個頂點\nctx.lineTo(x + 90, y + 100)  # 第五個頂點\nctx.lineTo(x + 60, y + 100)  # 第六個頂點\nctx.closePath()  # 關閉路徑，使六邊形封閉\nctx.fill()  # 填充六邊形的顏色\n\n# 繪製綠色菱形\nctx.beginPath()  # 開始繪製菱形\nctx.fillStyle = "#2CB05F"  # 設置填充顏色為綠色\nctx.moveTo(x + 130, y + 70)  # 菱形的第一個頂點\nctx.lineTo(x + 150, y + 40)  # 第二個頂點\nctx.lineTo(x + 170, y + 70)  # 第三個頂點\nctx.lineTo(x + 150, y + 100)  # 第四個頂點\nctx.closePath()  # 關閉路徑，將菱形閉合\nctx.fill()  # 填充菱形的顏色\n\n# 繪製藍色三角形\nctx.beginPath()  # 開始繪製三角形\nctx.fillStyle = "#73B7FF"  # 設置填充顏色為藍色\nctx.moveTo(x + 174, y + 70)  # 三角形的第一個頂點\nctx.lineTo(x + 154, y + 100)  # 第二個頂點（左下角）\nctx.lineTo(x + 194, y + 100)  # 第三個頂點（右下角）\nctx.closePath()  # 關閉路徑，將三角形閉合\nctx.fill()  # 填充三角形的顏色\n\n# 繪製粉紅色圓形\nctx.beginPath()  # 開始繪製圓形\nctx.fillStyle = "#FF458C"  # 設置填充顏色為粉紅色\nctx.arc(x + 220, y + 70, 20, 0, 2 * 3.14159)  # 定義圓形的圓心和半徑\nctx.fill()  # 填充圓形的顏色\n\n# 繪製黃色正方形\nctx.beginPath()  # 開始繪製正方形\nctx.fillStyle = "#EBDF00"  # 設置填充顏色為黃色\nctx.rect(x + 260, y + 43, 40, 40)  # 定義正方形的左上角和邊長\nctx.fill()  # 填充正方形的顏色\n\n# 繪製藍色矩形\nctx.beginPath()  # 開始繪製矩形\nctx.fillStyle = "#004A99"  # 設置填充顏色為藍色\nctx.rect(x + 320, y + 53, 60, 20)  # 定義矩形的左上角和寬高\nctx.fill()  # 填充矩形的顏色\n \n \n  利用 Brython 繪圖  \n \n', 'tags': '', 'url': 'w16_exam1.html'}, {'title': 'HW 3', 'text': '主題: Python 的數字、演算法與迴圈 (20%) \n Python 課程教材:  https://www.learnpythonwithjupyter.com/  - PART 4 and Part 5 \n 完成上述流程整理後, 請將 HW3 自評分數輸入 cp2024 自評表單中. \n \n', 'tags': '', 'url': 'HW 3.html'}, {'title': 'HW 3 Exam', 'text': '每六人為一組進行協同程式練習 \n 透過 Jupyterlab 協同網頁, 輪流指定各組編寫 HW 3 相關的程式練習, 以及網頁內容 (localhost 與 Codespaces 環境)編輯. \n', 'tags': '', 'url': 'HW 3 Exam.html'}, {'title': 'w16_exam2', 'text': '\n  導入 brython 程式庫  \n \n \n \n \n \n \n \n \n \n 程式學習收穫： \n 改進方向與延伸運用： \n \n \n 互動式迷宮： \n \n \n 添加用戶輸入功能，例如使用鍵盤方向鍵控制迷宮中的移動。 \n \n \n 在迷宮起點和終點設置指示點，用不同顏色或標誌表示，增強迷宮的互動性。 \n \n \n \n \n 自動生成迷宮： \n \n \n 實現一個算法（如深度優先搜索或Prim\'s Algorithm），動態生成迷宮路徑，避免手動編碼迷宮結構。 \n \n \n 將生成的迷宮數據存儲為陣列結構，然後根據數據繪製圖形。 \n \n \n \n \n 色彩與動態： \n \n \n 在迷宮中使用不同的顏色表示牆壁、路徑和探索進度。 \n \n \n 添加動畫效果，逐步展示迷宮的解路徑。 \n \n \n \n \n 擴展功能： \n \n \n 將迷宮保存為圖像文件（例如  .png ）。 \n \n \n 添加計時器，讓用戶挑戰解迷宮的速度。 \n \n \n 設置障礙或陷阱增加挑戰難度。 \n \n \n \n \n \n \n Canvas API 的應用：  深入學習  beginPath() 、 moveTo()  和  lineTo()  等核心方法，掌握如何控制圖形繪製過程。 \n \n \n 代碼可讀性提升：  系統性地添加註解，讓代碼不僅對自己而且對團隊成員更容易理解和修改。 \n \n \n 邏輯規劃：  將迷宮分段繪製，條理清晰，提升了程式設計的規劃能力。 \n \n \n \n sol: code \n Brython: code \n from browser import html\nfrom browser import document as doc\n\n# 創建 canvas 元素，並設置畫布的寬度和高度為 1000x250 像素\ncanvas = html.CANVAS(width=1000, height=250)\nbrython_div = doc["brython_div1"]  # 取得在 HTML 中 id 為 "brython_div1" 的元素\nbrython_div <= canvas  # 把 canvas 元素添加到指定的 div 中\n\n# 獲取 canvas 元素的 2D 渲染上下文 (context)，這樣就能在畫布上進行繪圖操作\nctx = canvas.getContext("2d")\n\n# 定義一個簡化的繪製直線的函數，這樣可以方便地多次使用\ndef draw_line(x1, y1, x2, y2, line_width=2, stroke_style="black"):\n    """\n    繪製一條直線，從 (x1, y1) 到 (x2, y2)，可設置線條寬度和顏色\n    """\n    ctx.lineWidth = line_width  # 設定線條的寬度\n    ctx.strokeStyle = stroke_style  # 設定線條的顏色\n    ctx.beginPath()  # 開始繪製路徑\n    ctx.moveTo(x1, y1)  # 把畫筆移動到起始點 (x1, y1)\n    ctx.lineTo(x2, y2)  # 繪製一條線條，從 (x1, y1) 到 (x2, y2)\n    ctx.stroke()  # 進行繪製，顯示線條\n\n# 定義一個繪製文本的函數\ndef draw_text(text, x, y, font="20px Arial", fill_style="black"):\n    """\n    在畫布上繪製文本，設置字體、顏色以及文本的位置\n    """\n    ctx.font = font  # 設置字體樣式\n    ctx.fillStyle = fill_style  # 設置文本顏色\n    ctx.fillText(text, x, y)  # 在 (x, y) 位置繪製文本\n\n# 繪製 L 形的線條，這是一個簡單的 L 形結構\ndef draw_l_shape(x, y):\n    """\n    繪製 L 形的兩條線條\n    第一條線從 (x, y) 到 (x + 300, y) — 水平線\n    第二條線從 (x, y) 到 (x, y + 300) — 垂直線\n    """\n    draw_line(x, y, x + 300, y)  # 繪製水平線\n    draw_line(x, y, x, y + 300)  # 繪製垂直線\n\n# 繪製紅色短線，這兩條短線用來強調指定的點\ndef draw_red_short_lines(x, y):\n    """\n    繪製兩條紅色的短線，用來標記 (x, y) 的位置\n    第一條是從 (x, y) 向下 1 像素的紅色短線\n    第二條是從 (x, y) 向右 1 像素的紅色短線\n    """\n    draw_line(x, y, x, y + 1, line_width=5, stroke_style="red")  # 繪製垂直的紅色短線\n    draw_line(x, y, x + 1, y, line_width=5, stroke_style="red")  # 繪製水平的紅色短線\n\n# 繪製藍色的六邊形多邊形\ndef draw_blue_polygon():\n    """\n    繪製一個由 6 條藍色線條組成的封閉多邊形\n    這個多邊形的每一條邊都是藍色的\n    """\n    # 各條邊的坐標順序\n    draw_line(130, 130, 170, 130, stroke_style="blue")  # 第一條邊\n    draw_line(190, 130, 230, 130, stroke_style="blue")  # 第二條邊\n    draw_line(230, 130, 230, 230, stroke_style="blue")  # 第三條邊\n    draw_line(230, 230, 190, 230, stroke_style="blue")  # 第四條邊\n    draw_line(170, 230, 130, 230, stroke_style="blue")  # 第五條邊\n    draw_line(130, 230, 130, 130, stroke_style="blue")  # 第六條邊\n\n# 繪製矩形內部的藍色線條，這些線條在矩形內部創建更多的小區域\ndef draw_inner_lines_in_rectangle():\n    """\n    繪製矩形內部的藍色線條，形成更多的小區域\n    """\n    # 這些線條是繪製在 (150, 150) 和 (210, 230) 之間的區域\n    draw_line(150, 150, 210, 150, stroke_style="blue")  # 上邊\n    draw_line(210, 150, 210, 170, stroke_style="blue")  # 右邊\n    draw_line(170, 150, 170, 170, stroke_style="blue")  # 中間的垂直線\n    draw_line(170, 170, 130, 170, stroke_style="blue")  # 下邊\n    draw_line(190, 170, 190, 190, stroke_style="blue")  # 內部短垂直線\n    draw_line(190, 190, 210, 190, stroke_style="blue")  # 內部短水平線\n    draw_line(210, 190, 210, 230, stroke_style="blue")  # 右邊\n    draw_line(170, 170, 150, 170, stroke_style="blue")  # 左邊\n    draw_line(150, 210, 150, 190, stroke_style="blue")  # 內部左邊\n    draw_line(150, 190, 190, 190, stroke_style="blue")  # 內部底部\n    draw_line(170, 230, 170, 210, stroke_style="blue")  # 內部右邊\n    draw_line(170, 210, 190, 210, stroke_style="blue")  # 內部右側底部\n\n# 主函數，負責調用所有繪圖函數來執行繪製操作\ndef main():\n    """\n    主函數，負責調用各種繪圖函數來完成圖形的繪製\n    """\n    # 繪製 L 形線條，起始位置為 (31, 42)\n    draw_l_shape(31, 42)\n\n    # 繪製紅色短線條，強調 (31, 42) 的位置\n    draw_red_short_lines(31, 42)\n\n    # 繪製文本 "(31,42)"，並將其放置在適當的 y 位置，避免與其他圖形重疊\n    draw_text("(31,42)", 40, 35, font="20px Arial", fill_style="red")\n\n    # 繪製藍色的多邊形\n    draw_blue_polygon()\n\n    # 繪製矩形內部的藍色線條，創建更多的小區域\n    draw_inner_lines_in_rectangle()\n\n# 調用主函數，執行所有繪圖操作\nmain() \n \n', 'tags': '', 'url': 'w16_exam2.html'}, {'title': 'HW 4', 'text': '主題: 利用 Python 控制機電模擬系統 (20%) \n 利用\xa0 https://solvespace.com/ \xa0建立機械系統零組件 \n 利用  CoppeliaSim  建立機電模擬系統 \n 利用  Python  跨網路控制瀏覽器上的機電模擬系統 \n 範例: \n cd2023_pj3ag4_zmq_football_4.7.7z \n cd2024_2b_g6_steel_ball_platform_nxopen_copsim.7z \n 完成上述流程整理後, 請將 HW4 自評分數輸入 cp2024 自評表單中. \n \n', 'tags': '', 'url': 'HW 4.html'}, {'title': 'HW 4 Exam', 'text': '每六人為一組進行協同程式練習 \n 透過 Jupyterlab 協同網頁, 輪流指定各組編寫 HW 4 相關的程式練習, 以及網頁內容 (localhost 與 Codespaces 環境)編輯. \n', 'tags': '', 'url': 'HW 4 Exam.html'}, {'title': 'w16_exam3', 'text': '一開始，我是透過ChatGPT了解如何繪製程式碼的功能和語法，接著自己進行計算並撰寫程式碼，尋找對應的色碼輸入，然後將程式碼上傳。這整個學期的過程，不僅讓我在課堂上學到了計算機程式的知識，也讓我學會了如何更有效地利用GPT來進行學習。我不再只是簡單地複製，而是透過不斷提問來解決理解上的問題，補足我的知識盲點，也改善了我的英文能力。GPT還能針對我不理解的地方進行加強說明，讓我在未來再次閱讀時，依然能夠理解。 \n \n \n 靈活使用 HTML Canvas API 透過  ctx.beginPath()  等 API，可以有效管理繪圖路徑並避免線條相互干擾。此外，運用  moveTo  和  lineTo  等方法，清晰地描述迷宮的各部分結構，讓繪製過程井然有序。 \n 模組化與參數化設計 在程式中利用變數（如  origin_x  和  origin_y ），可以輕鬆調整整體迷宮的位置偏移，讓繪圖更靈活。這種參數化的設計有助於後續維護及擴展。 \n 走迷宮邏輯的規劃 使用單獨的區塊繪製走迷宮路徑，將每一步都以簡單的線條指令表示，讓迷宮的解法可視化，直觀易懂。 \n 色彩與線條設置 運用  strokeStyle  和  lineWidth ，明確區分迷宮框架與解路徑，提升圖形的可讀性和視覺效果。 \n 程式結構的清晰性 透過明確的註解，對程式的每個部分進行詳細解釋，這不僅方便日後檢視，也利於其他開發者理解。 \n 學習與應用 Canvas API 的實踐 這次實現迷宮繪製的過程提供了全面操作 Canvas 的實踐機會，涵蓋了基本線條繪製、文字繪製、色彩管理等多方面內容。 \n 改進空間 \n \n 可以將迷宮的結構數據化，使用陣列或物件表示迷宮結構，進一步提高程式的可重用性。 \n 自動生成迷宮路徑，增強互動性與挑戰性。 \n 增加迷宮的動畫效果，讓視覺呈現更動態化。 \n \n \n \n \n sol: code \n Bython: code \n \n from browser import html\nfrom browser import document as doc\n\n# 創建 canvas 元素，並設置畫布的寬度和高度為 1000x300 像素\ncanvas = html.CANVAS(width=1000, height=300)\nbrython_div = doc["brython_div1"]  # 取得在 HTML 中 id 為 "brython_div1" 的元素\nbrython_div <= canvas  # 把 canvas 元素添加到指定的 div 中\n\n# 取得 canvas 元素的 2D 渲染上下文 (context)，這樣就能在畫布上進行繪圖操作\nctx = canvas.getContext("2d")\n\n# 定義一個簡化的繪製直線的函數，這樣可以方便地多次使用\ndef draw_line(x1, y1, x2, y2, line_width=2, stroke_style="black"):\n    """\n    繪製一條直線，從 (x1, y1) 到 (x2, y2)，可設定線條寬度和顏色\n    """\n    ctx.lineWidth = line_width  # 設定線條的寬度\n    ctx.strokeStyle = stroke_style  # 設定線條的顏色\n    ctx.beginPath()  # 開始繪製路徑\n    ctx.moveTo(x1, y1)  # 把畫筆移動到起始點 (x1, y1)\n    ctx.lineTo(x2, y2)  # 繪製一條線條，從 (x1, y1) 到 (x2, y2)\n    ctx.stroke()  # 進行繪製，顯示線條\n\n# 定義一個繪製文本的函數\ndef draw_text(text, x, y, font="20px Arial", fill_style="black"):\n    """\n    在畫布上繪製文本，設定字體、顏色以及文本的位置\n    """\n    ctx.font = font  # 設定字體樣式\n    ctx.fillStyle = fill_style  # 設定文本顏色\n    ctx.fillText(text, x, y)  # 在 (x, y) 位置繪製文本\n    ctx.font = "12px Arial"\n    ctx.fillStyle = "red"\n    ctx.fillText("入口", 170, 110)  # 在指定位置繪製“入口”字樣\n    ctx.fillText("出口", 170, 260)  # 在指定位置繪製“出口”字樣\n\n# 繪製紅色線條的函數\ndef draw_red_path():\n    """\n    繪製一條紅色路徑\n    """\n    # 繪製紅色路徑的每條線段\n    draw_line(180, 130, 180, 140, stroke_style="red")  # 繪製直線段\n    draw_line(180, 140, 220, 140, stroke_style="red")  # 繪製直線段\n    draw_line(220, 140, 220, 180, stroke_style="red")  # 繪製直線段\n    draw_line(220, 180, 200, 180, stroke_style="red")  # 繪製直線段\n    draw_line(200, 180, 200, 160, stroke_style="red")  # 繪製直線段\n    draw_line(200, 160, 180, 160, stroke_style="red")  # 繪製直線段\n    draw_line(180, 160, 180, 180, stroke_style="red")  # 繪製直線段\n    draw_line(180, 180, 140, 180, stroke_style="red")  # 繪製直線段\n    draw_line(140, 180, 140, 220, stroke_style="red")  # 繪製直線段\n    draw_line(140, 220, 160, 220, stroke_style="red")  # 繪製直線段\n    draw_line(160, 220, 160, 200, stroke_style="red")  # 繪製直線段\n    draw_line(160, 200, 200, 200, stroke_style="red")  # 繪製直線段\n    draw_line(200, 200, 200, 220, stroke_style="red")  # 繪製直線段\n    draw_line(200, 220, 180, 220, stroke_style="red")  # 繪製直線段\n    draw_line(180, 220, 180, 230, stroke_style="red")  # 繪製直線段\n\n# 繪製 L 形的線條，這是一條簡單的 L 形結構\ndef draw_l_shape(x, y):\n    """\n    繪製 L 形的兩條線條\n    第一條線從 (x, y) 到 (x + 300, y) — 水平線\n    第二條線從 (x, y) 到 (x, y + 300) — 垂直線\n    """\n    draw_line(x, y, x + 300, y)  # 繪製水平線\n    draw_line(x, y, x, y + 300)  # 繪製垂直線\n\n# 繪製紅色短線，這兩條短線用來強調指定的點\ndef draw_red_short_lines(x, y):\n    """\n    繪製兩條紅色的短線，用來標記 (x, y) 的位置\n    第一條是從 (x, y) 向下 1 像素的紅色短線\n    第二條是從 (x, y) 向右 1 像素的紅色短線\n    """\n    draw_line(x, y, x, y + 1, line_width=5, stroke_style="red")  # 繪製垂直的紅色短線\n    draw_line(x, y, x + 1, y, line_width=5, stroke_style="red")  # 繪製水平的紅色短線\n\n# 繪製藍色的六邊形多邊形\ndef draw_blue_polygon():\n    """\n    繪製一個由 6 條藍色線條組成的封閉多邊形\n    這個多邊形的每一條邊都是黑色的\n    """\n    # 各條邊的坐標順序\n    draw_line(130, 130, 170, 130, stroke_style="black")  # 第一條邊\n    draw_line(190, 130, 230, 130, stroke_style="black")  # 第二條邊\n    draw_line(230, 130, 230, 230, stroke_style="black")  # 第三條邊\n    draw_line(230, 230, 190, 230, stroke_style="black")  # 第四條邊\n    draw_line(170, 230, 130, 230, stroke_style="black")  # 第五條邊\n    draw_line(130, 230, 130, 130, stroke_style="black")  # 第六條邊\n\n# 繪製矩形內部的藍色線條，這些線條在矩形內部創建更多的小區域\ndef draw_inner_lines_in_rectangle():\n    """\n    繪製矩形內部的藍色線條，形成更多的小區域\n    """\n    # 這些線條是繪製在 (150, 150) 和 (210, 230) 之間的區域\n    draw_line(150, 150, 210, 150, stroke_style="black")  # 上邊\n    draw_line(210, 150, 210, 170, stroke_style="black")  # 右邊\n    draw_line(170, 150, 170, 170, stroke_style="black")  # 中間的垂直線\n    draw_line(170, 170, 130, 170, stroke_style="black")  # 下邊\n    draw_line(190, 170, 190, 190, stroke_style="black")  # 內部短垂直線\n    draw_line(190, 190, 210, 190, stroke_style="black")  # 內部短水平線\n    draw_line(210, 190, 210, 230, stroke_style="black")  # 右邊\n    draw_line(170, 170, 150, 170, stroke_style="black")  # 左邊\n    draw_line(150, 210, 150, 190, stroke_style="black")  # 內部左邊\n    draw_line(150, 190, 190, 190, stroke_style="black")  # 內部底部\n    draw_line(170, 230, 170, 210, stroke_style="black")  # 內部右邊\n    draw_line(170, 210, 190, 210, stroke_style="black")  # 內部右側底部\n\n# 主函數，負責調用所有繪圖函數來執行繪製操作\ndef main():\n    """\n    主函數，負責調用各種繪圖函數來完成圖形的繪製\n    """\n    # 繪製 L 形線條，起始位置為 (31, 42)\n    draw_l_shape(31, 42)\n\n    # 繪製紅色短線條，強調 (31, 42) 的位置\n    draw_red_short_lines(31, 42)\n\n    # 繪製文本 "(31,42)"，並將其放置在適當的 y 位置，避免與其他圖形重疊\n    draw_text("(31,42)", 40, 35, font="20px Arial", fill_style="red")\n\n    # 繪製紅色路徑\n    draw_red_path()\n\n    # 繪製藍色的多邊形\n    draw_blue_polygon()\n\n    # 繪製矩形內部的藍色線條，創建更多的小區域\n    draw_inner_lines_in_rectangle()\n\n# 調用主函數，執行所有繪圖操作\nmain() \n', 'tags': '', 'url': 'w16_exam3.html'}, {'title': 'Final Report', 'text': '期末口頭與書面專題報告 (20%) \n 期末口頭專題報告影片: \n ...... \n 期末書面專題報告檔案 (pdf): \n ...... \n 電腦輔助設計與實習課程總結心得: \n ...... \n 期末報告自評成績: \n 完成上述流程後, 請將 Final Report 自評分數輸入 cp2024 自評表單中. \n \n', 'tags': '', 'url': 'Final Report.html'}, {'title': 'Final\xa0Program Library', 'text': '在沒有 AI 的協助下, 以 Python 語法解決問題 \n', 'tags': '', 'url': 'Final\xa0Program Library.html'}, {'title': '程式庫', 'text': '', 'tags': '', 'url': '程式庫.html'}, {'title': '簡單的數學計算器', 'text': '\n 寫一個函數 `calculate`，接受三個參數：操作（加、減、乘、除）和兩個數字。根據操作進行對應的計算並返回結果。 \n \n def calculate(operation, num1, num2):  # 定義函數 calculate，接受三個參數：操作符、第一個數字和第二個數字\n    """\n    根據指定的操作符對兩個數字進行計算並返回結果。\n    """\n    if operation == "加":  # 檢查操作符是否為 "加"\n        return num1 + num2  # 返回兩個數字的加法結果\n    elif operation == "減":  # 檢查操作符是否為 "減"\n        return num1 - num2  # 返回兩個數字的減法結果\n    elif operation == "乘":  # 檢查操作符是否為 "乘"\n        return num1 * num2  # 返回兩個數字的乘法結果\n    elif operation == "除":  # 檢查操作符是否為 "除"\n        if num2 != 0:  # 確保第二個數字不是零，避免除以零的錯誤\n            return num1 / num2  # 返回兩個數字的除法結果\n        else:  # 如果第二個數字是零\n            return "錯誤：不能除以零！"  # 返回錯誤訊息\n    else:  # 如果操作符不是加、減、乘或除\n        return "錯誤：無效的操作！"  # 返回錯誤訊息\nprint(calculate("加", 10, 5)) \n \n 寫一個函數 `advanced_calculate`，接受四個參數：操作（加、減、乘、除、次方、取餘數）和兩個數字，以及一個布林值參數，表示是否要返回計算步驟的詳細過程。根據操作進行對應的計算並返回結果和計算步驟（若布林值為真）。\n def advanced_calculate(operation, num1, num2, show_steps):  \n    """\n    根據指定的操作對兩個數字進行計算，並根據布林值決定是否返回計算步驟。\n    \n    參數：\n    - operation: 字符串，指定操作類型（加、減、乘、除、次方、取餘數）\n    - num1: 第一個數字\n    - num2: 第二個數字\n    - show_steps: 布林值，若為 True，則返回計算步驟\n\n    返回：\n    - 若 show_steps 為 False，僅返回計算結果\n    - 若 show_steps 為 True，返回計算結果和步驟描述\n\n    測試範例：\n    # 測試加法並顯示計算步驟\n    print(advanced_calculate("加", 10, 5, True))  # 輸出 (15, "10 + 5 = 15")\n\n    # 測試減法並不顯示計算步驟\n    print(advanced_calculate("減", 10, 5, False))  # 輸出 5\n\n    # 測試乘法並顯示計算步驟\n    print(advanced_calculate("乘", 10, 5, True))  # 輸出 (50, "10 * 5 = 50")\n\n    # 測試除法並顯示計算步驟\n    print(advanced_calculate("除", 10, 5, True))  # 輸出 (2.0, "10 / 5 = 2.0")\n\n    # 測試次方\n    print(advanced_calculate("次方", 2, 3, True))  # 輸出 (8, "2 ^ 3 = 8")\n\n    # 測試取餘數\n    print(advanced_calculate("取餘數", 10, 3, True))  # 輸出 (1, "10 % 3 = 1")\n\n    # 測試無效操作符\n    print(advanced_calculate("平方根", 10, 5, True))  # 輸出 "錯誤：無效的操作！"\n\n    # 測試除以零\n    print(advanced_calculate("除", 10, 0, True))  # 輸出 "錯誤：不能除以零！"\n    """\n    steps = ""  # 初始化用於存儲步驟的變數\n    \n    if operation == "加":  # 檢查是否執行加法\n        result = num1 + num2  # 計算加法結果\n        steps = f"{num1} + {num2} = {result}"  # 記錄加法步驟\n    elif operation == "減":  # 檢查是否執行減法\n        result = num1 - num2  # 計算減法結果\n        steps = f"{num1} - {num2} = {result}"  # 記錄減法步驟\n    elif operation == "乘":  # 檢查是否執行乘法\n        result = num1 * num2  # 計算乘法結果\n        steps = f"{num1} * {num2} = {result}"  # 記錄乘法步驟\n    elif operation == "除":  # 檢查是否執行除法\n        if num2 != 0:  # 確保除數不為零\n            result = num1 / num2  # 計算除法結果\n            steps = f"{num1} / {num2} = {result}"  # 記錄除法步驟\n        else:\n            return "錯誤：不能除以零！"  # 返回錯誤訊息\n    elif operation == "次方":  # 檢查是否執行次方\n        result = num1 ** num2  # 計算次方結果\n        steps = f"{num1} ^ {num2} = {result}"  # 記錄次方步驟\n    elif operation == "取餘數":  # 檢查是否執行取餘數\n        result = num1 % num2  # 計算餘數\n        steps = f"{num1} % {num2} = {result}"  # 記錄取餘數步驟\n    else:  # 無效操作符的情況\n        return "錯誤：無效的操作！"  # 返回錯誤訊息\n\n    # 根據 show_steps 決定返回結果\n    if show_steps:  # 如果需要顯示計算步驟\n        return result, steps  # 返回結果和步驟\n    else:  # 如果不需要顯示計算步驟\n        return result  # 僅返回結果\n \n \n \n \n \n 寫一個函數 `unit_converter`，接受三個參數：轉換類型（例如：米-公里、克-千克、華氏-攝氏）和兩個數字（值與小數點後的位數）。根據轉換類型進行對應的單位轉換並返回結果。\n def unit_converter(conversion_type, value, decimal_places):  \n    """\n    根據指定的轉換類型對值進行單位轉換，並根據指定的小數點位數返回結果。\n    \n    參數：\n    - conversion_type: 字符串，轉換類型（例如：米-公里、克-千克、華氏-攝氏）\n    - value: 數值，需要轉換的數字\n    - decimal_places: 整數，小數點後保留的位數\n\n    返回：\n    - 轉換結果，保留指定的小數點位數\n\n    測試範例：\n    # 測試米到公里\n    print(unit_converter("米-公里", 1500, 2))  # 輸出 1.50\n\n    # 測試克到千克\n    print(unit_converter("克-千克", 500, 3))  # 輸出 0.500\n\n    # 測試華氏到攝氏\n    print(unit_converter("華氏-攝氏", 98.6, 1))  # 輸出 37.0\n\n    # 測試無效轉換類型\n    print(unit_converter("公里-米", 1, 2))  # 輸出 "錯誤：無效的轉換類型！"\n    """\n    if conversion_type == "米-公里":  # 檢查是否進行米到公里的轉換\n        result = value / 1000  # 將數值從米轉換為公里\n    elif conversion_type == "克-千克":  # 檢查是否進行克到千克的轉換\n        result = value / 1000  # 將數值從克轉換為千克\n    elif conversion_type == "華氏-攝氏":  # 檢查是否進行華氏到攝氏的轉換\n        result = (value - 32) * 5 / 9  # 使用公式將華氏轉換為攝氏\n    else:  # 如果轉換類型無效\n        return "錯誤：無效的轉換類型！"  # 返回錯誤訊息\n\n    # 返回結果，保留指定的小數點位數\n    return round(result, decimal_places)  # 使用 round() 函數保留指定的小數點位數\n \n \n \n \n \n 寫一個函數 `math_quiz`，隨機生成一個數學問題（加、減、乘、除），並接受使用者的答案。檢查答案是否正確，並返回 "正確" 或 "錯誤"。\n import random  # 引入隨機模組，用於生成隨機數和隨機操作\n\ndef math_quiz():\n    """\n    隨機生成一個數學問題（加、減、乘、除），並接受使用者的答案。\n    檢查答案是否正確，並返回 "正確" 或 "錯誤"。\n    \n    返回：\n    - "正確"：若使用者答案正確\n    - "錯誤"：若使用者答案錯誤\n    """\n    # 定義可用的操作類型\n    operations = ["+", "-", "*", "/"]\n    # 隨機選擇一個操作\n    operation = random.choice(operations)\n    # 隨機生成兩個數字\n    num1 = random.randint(1, 100)\n    num2 = random.randint(1, 100)\n\n    # 確保除法時除數不為零，並保證整數結果\n    if operation == "/":\n        num1 = num1 * num2  # 保證結果為整數，避免小數問題\n\n    # 根據操作計算正確答案\n    if operation == "+":\n        correct_answer = num1 + num2\n    elif operation == "-":\n        correct_answer = num1 - num2\n    elif operation == "*":\n        correct_answer = num1 * num2\n    elif operation == "/":\n        correct_answer = num1 // num2  # 整數除法\n\n    # 顯示問題給使用者\n    print(f"問題：{num1} {operation} {num2} = ?")\n\n    # 接受使用者輸入的答案\n    try:\n        user_answer = int(input("請輸入你的答案："))  # 將輸入轉換為整數\n    except ValueError:\n        return "錯誤：請輸入有效的數字！"  # 如果輸入無效，提示錯誤\n\n    # 比較使用者答案與正確答案\n    if user_answer == correct_answer:\n        return "正確"\n    else:\n        return "錯誤"\n\n# 測試範例\nif __name__ == "__main__":\n    # 多次執行測試以檢查功能\n    print(math_quiz())  # 問題將隨機生成，結果根據答案顯示 "正確" 或 "錯誤"\n \n \n \n \n \n 寫一個函數 `basic_statistics`，接受一個包含數字的清單，並返回該清單的平均數、中位數和標準差。\n import statistics  # 引入 statistics 模組，用於計算中位數和標準差\n\ndef basic_statistics(numbers):\n    """\n    計算一個包含數字的清單的基本統計量：平均數、中位數和標準差。\n    \n    參數：\n    - numbers: 一個包含數字的清單\n\n    返回：\n    - 一個字典，包含平均數（mean）、中位數（median）和標準差（std_dev）\n\n    測試範例：\n    # 測試清單 [10, 20, 30, 40, 50]\n    print(basic_statistics([10, 20, 30, 40, 50]))  \n    # 輸出 {\'mean\': 30.0, \'median\': 30, \'std_dev\': 15.811388300841896}\n    """\n    if not numbers:  # 檢查清單是否為空\n        return "錯誤：清單不能為空！"\n    \n    # 計算平均數\n    mean = sum(numbers) / len(numbers)  # 使用 sum() 和 len() 計算平均數\n    \n    # 計算中位數\n    median = statistics.median(numbers)  # 使用 statistics.median() 計算中位數\n    \n    # 計算標準差\n    std_dev = statistics.stdev(numbers) if len(numbers) > 1 else 0  # 保證至少有兩個數字才計算標準差\n\n    # 將結果組成字典返回\n    return {\n        "mean": mean,       # 平均數\n        "median": median,   # 中位數\n        "std_dev": std_dev  # 標準差\n    }\n\n# 測試範例\nif __name__ == "__main__":\n    # 測試非空清單\n    print(basic_statistics([10, 20, 30, 40, 50]))  \n    # 輸出 {\'mean\': 30.0, \'median\': 30, \'std_dev\': 15.811388300841896}\n\n    # 測試單一元素清單\n    print(basic_statistics([100]))  \n    # 輸出 {\'mean\': 100.0, \'median\': 100, \'std_dev\': 0}\n\n    # 測試空清單\n    print(basic_statistics([]))  \n    # 輸出 "錯誤：清單不能為空！"\n \n \n \n \n \n 寫一個函數 `geometry_calculator`，接受三個參數：形狀類型（例如：圓形、矩形、三角形）和兩個數字（對應的長度或寬度等）。根據形狀類型計算並返回面積。\n import math  # 引入 math 模組，用於處理圓形的計算\n\ndef geometry_calculator(shape, num1, num2=0):\n    """\n    根據形狀類型計算面積。\n    \n    參數：\n    - shape: 字符串，表示形狀類型（"圓形", "矩形", "三角形"）\n    - num1: 第一個數字（例如半徑、長度或底邊）\n    - num2: 第二個數字（例如高度或寬度，圓形可忽略）\n\n    返回：\n    - 該形狀的面積（浮點數）\n    - 或錯誤提示字串，若形狀類型無效或參數不正確\n\n    測試範例：\n    # 測試圓形\n    print(geometry_calculator("圓形", 5))  \n    # 輸出 78.53981633974483\n\n    # 測試矩形\n    print(geometry_calculator("矩形", 4, 5))  \n    # 輸出 20.0\n\n    # 測試三角形\n    print(geometry_calculator("三角形", 6, 8))  \n    # 輸出 24.0\n\n    # 測試無效形狀\n    print(geometry_calculator("五邊形", 3, 4))  \n    # 輸出 "錯誤：不支持的形狀類型！"\n    """\n    # 根據形狀類型進行計算\n    if shape == "圓形":\n        if num1 <= 0:  # 確保半徑有效\n            return "錯誤：圓形的半徑必須大於 0！"\n        return math.pi * num1 ** 2  # 計算圓的面積公式：πr^2\n    \n    elif shape == "矩形":\n        if num1 <= 0 or num2 <= 0:  # 確保長寬有效\n            return "錯誤：矩形的長和寬必須大於 0！"\n        return num1 * num2  # 計算矩形的面積公式：長 × 寬\n    \n    elif shape == "三角形":\n        if num1 <= 0 or num2 <= 0:  # 確保底邊和高度有效\n            return "錯誤：三角形的底和高必須大於 0！"\n        return 0.5 * num1 * num2  # 計算三角形的面積公式：0.5 × 底 × 高\n    \n    else:\n        return "錯誤：不支持的形狀類型！"  # 若形狀類型無效，返回錯誤訊息\n\n# 測試範例\nif __name__ == "__main__":\n    # 測試圓形\n    print(geometry_calculator("圓形", 5))  \n    # 輸出 78.53981633974483\n\n    # 測試矩形\n    print(geometry_calculator("矩形", 4, 5))  \n    # 輸出 20.0\n\n    # 測試三角形\n    print(geometry_calculator("三角形", 6, 8))  \n    # 輸出 24.0\n\n    # 測試無效形狀\n    print(geometry_calculator("五邊形", 3, 4))  \n    # 輸出 "錯誤：不支持的形狀類型！"\n \n \n', 'tags': '', 'url': '簡單的數學計算器.html'}, {'title': '反轉字串', 'text': '寫一個函數 `reverse_string`，接受一個字串作為參數，並返回該字串的反轉版本。例如：`reverse_string("hello")` 應返回 `olleh`。 \n def reverse_string(s):\n    return s[::-1]  # 使用切片方法反轉字串\n\n# 測試函數\nprint(reverse_string("hello"))  # 輸出: olleh\n \n 寫一個函數 string_length，接受一個字串作為參數，並返回該字串的長度。例如：string_length("hello") 應返回 5。 \n def string_length(s):\n    return len(s)  # 使用內建的 len() 函數來計算字串的長度\n\n# 測試函數\nprint(string_length("hello"))  # 輸出: 5\n \n 寫一個函數 toggle_case，接受一個字串作為參數，並返回該字串中每個字母大小寫互換後的版本。例如：toggle_case("Hello") 應返回 hELLO。 \n def toggle_case(s):\n    return s.swapcase()  # 使用內建的 swapcase() 函數來互換字母的大小寫\n\n# 測試函數\nprint(toggle_case("Hello"))  # 輸出: hELLO\n \n 寫一個函數 word_count，接受一個字串作為參數，並返回該字串中單詞的數量。例如：word_count("Hello world") 應返回 2。 \n def word_count(s):\n    words = s.split()  # 使用 split() 函數將字串分割為單詞\n    return len(words)  # 返回單詞的數量\n\n# 測試函數\nprint(word_count("Hello world"))  # 輸出: 2\n \n 寫一個函數 is_palindrome，接受一個字串作為參數，並返回該字串是否為迴文（正反讀都相同）。例如：is_palindrome("madam") 應返回 True。 \n def is_palindrome(s):\n    return s == s[::-1]  # 檢查字串是否等於它的反轉版本\n\n# 測試函數\nprint(is_palindrome("madam"))  # 輸出: True\nprint(is_palindrome("hello"))  # 輸出: False\n \n 寫一個函數 split_string，接受一個字串和一個分隔符作為參數，並返回一個包含切割後子字串的清單。例如：split_string("hello world", " ") 應返回 [\'hello\', \'world\']。 \n def split_string(s, delimiter):\n    return s.split(delimiter)  # 使用 split() 函數根據分隔符切割字串\n\n# 測試函數\nprint(split_string("hello world", " "))  # 輸出: [\'hello\', \'world\']\n \n', 'tags': '', 'url': '反轉字串.html'}, {'title': '費氏數列', 'text': '寫一個函數 `fibonacci`，接受一個整數 `n`，並返回長度為 `n` 的費氏數列。例如：`fibonacci(5)` 應返回 `[0, 1, 1, 2, 3]`。 \n def fibonacci(n):\n    # 初始化費氏數列，前兩個數字是 0 和 1\n    fib_sequence = [0, 1]\n    \n    # 如果 n 是 1，則只返回 [0]\n    if n == 1:\n        return [0]\n    \n    # 如果 n 是 2，則返回 [0, 1]\n    if n == 2:\n        return fib_sequence\n    \n    # 使用迴圈生成剩餘的費氏數字\n    for i in range(2, n):\n        next_fib = fib_sequence[-1] + fib_sequence[-2]  # 計算下個費氏數字\n        fib_sequence.append(next_fib)  # 將數字加入數列\n    \n    return fib_sequence\n\n# 測試函數\nresult = fibonacci(5)\nprint(result)  # 輸出: [0, 1, 1, 2, 3]\n \n 階乘計算： 寫一個函數 factorial，接受一個整數 n，並返回 n 的階乘。例如：factorial(5) 應返回 120。 \n def factorial(n):\n    # 初始階乘值為 1\n    result = 1\n    # 使用 for 迴圈計算階乘\n    for i in range(1, n + 1):\n        result *= i  # 將當前數字乘到結果中\n    return result\n\n# 測試函數\nresult = factorial(5)\nprint(result)  # 輸出: 120\n \n 最小公倍數： 寫一個函數 lcm，接受兩個整數 a 和 b，並返回它們的最小公倍數。例如：lcm(6, 8) 應返回 24。 \n import math\n\ndef lcm(a, b):\n    # 計算最大公因數（GCD）\n    gcd = math.gcd(a, b)\n    # 計算最小公倍數（LCM）\n    return abs(a * b) // gcd\n\n# 測試函數\nresult = lcm(6, 8)\nprint(result)  # 輸出: 24\n \n 最大公因數： 寫一個函數 gcd，接受兩個整數 a 和 b，並返回它們的最大公因數。例如：gcd(48, 18) 應返回 6。 \n def gcd(a, b):\n    # 使用歐幾里得算法計算最大公因數\n    while b != 0:\n        a, b = b, a % b  # 將 a 更新為 b，b 更新為 a 除以 b 的餘數\n    return a\n\n# 測試函數\nresult = gcd(48, 18)\nprint(result)  # 輸出: 6\n \n 階乘和： 寫一個函數 sum_of_factorials，接受一個整數 n，並返回從 1 到 n 的所有整數的階乘和。例如：sum_of_factorials(3) 應返回 9（1! + 2! + 3! = 1 + 2 + 6）。 \n import math\n\ndef sum_of_factorials(n):\n    # 初始化總和為 0\n    total_sum = 0\n    # 計算從 1 到 n 的所有階乘並累加\n    for i in range(1, n + 1):\n        total_sum += math.factorial(i)  # 計算 i 的階乘並累加\n    return total_sum\n\n# 測試函數\nresult = sum_of_factorials(3)\nprint(result)  # 輸出: 9 (1! + 2! + 3! = 1 + 2 + 6)\n \n 二項式係數： 寫一個函數 binomial_coefficient，接受兩個整數 n 和 k，並返回二項式係數 "n 選 k"（n choose k）。例如：binomial_coefficient(5, 2) 應返回 10。 \n import math\n\ndef binomial_coefficient(n, k):\n    # 使用二項式係數公式 C(n, k) = n! / (k! * (n-k)!)\n    return math.factorial(n) // (math.factorial(k) * math.factorial(n - k))\n\n# 測試函數\nresult = binomial_coefficient(5, 2)\nprint(result)  # 輸出: 10\n \n', 'tags': '', 'url': '費氏數列.html'}, {'title': '清單排序', 'text': '寫一個函數 `sort_list`，接受一個包含整數的清單作為參數，並返回該清單的排序版本（從小到大）。例如：`sort_list([3, 1, 4, 1, 5])` 應返回 `[1, 1, 3, 4, 5]`。 \n def sort_list(lst):\n    # 使用內建的 sorted 函數對清單進行排序並返回排序後的清單\n    return sorted(lst)\n\n# 測試函數\nresult = sort_list([3, 1, 4, 1, 5])\nprint(result)  # 輸出: [1, 1, 3, 4, 5]\n \n 寫一個函數 remove_duplicates，接受一個包含整數的清單作為參數，並返回去除重複元素後的清單。例如：remove_duplicates([1, 2, 2, 3, 4, 4, 5]) 應返回 [1, 2, 3, 4, 5]。 \n def remove_duplicates(lst):\n    # 使用 set() 去除重複的元素，並使用 list() 轉回清單\n    return list(set(lst))\n\n# 測試函數\nresult = remove_duplicates([1, 2, 2, 3, 4, 4, 5])\nprint(result)  # 輸出: [1, 2, 3, 4, 5]\n \n 寫一個函數 reverse_list，接受一個包含整數的清單作為參數，並返回該清單的反轉版本。例如：reverse_list([1, 2, 3, 4, 5]) 應返回 [5, 4, 3, 2, 1]。 \n def reverse_list(lst):\n    # 使用內建的 reversed 函數反轉清單，並將其轉回清單\n    return list(reversed(lst))\n\n# 測試函數\nresult = reverse_list([1, 2, 3, 4, 5])\nprint(result)  # 輸出: [5, 4, 3, 2, 1]\n \n 寫一個函數 find_max_min，接受一個包含整數的清單作為參數，並返回一個包含最大值和最小值的元組。例如：find_max_min([3, 1, 4, 1, 5]) 應返回 (5, 1)。 \n def find_max_min(lst):\n    # 使用內建的 max() 和 min() 函數分別獲取最大值和最小值\n    return (max(lst), min(lst))\n\n# 測試函數\nresult = find_max_min([3, 1, 4, 1, 5])\nprint(result)  # 輸出: (5, 1)\n \n 寫一個函數 cumulative_sum，接受一個包含整數的清單作為參數，並返回該清單的累積和清單。例如：cumulative_sum([1, 2, 3, 4]) 應返回 [1, 3, 6, 10]。 \n def cumulative_sum(lst):\n    # 初始化一個空清單來存儲累積和\n    result = []\n    # 變數來記錄當前的累積和\n    total = 0\n    # 遍歷原清單，並計算累積和\n    for num in lst:\n        total += num  # 將當前數字加到累積和\n        result.append(total)  # 將累積和添加到結果清單\n    return result\n\n# 測試函數\nresult = cumulative_sum([1, 2, 3, 4])\nprint(result)  # 輸出: [1, 3, 6, 10]\n \n 寫一個函數 count_elements，接受一個包含整數的清單作為參數，並返回一個字典，該字典包含清單中每個元素出現的次數。例如：count_elements([1, 2, 2, 3, 3, 3]) 應返回 {1: 1, 2: 2, 3: 3}。 \n def count_elements(lst):\n    # 初始化一個空字典來存儲每個元素的出現次數\n    count_dict = {}\n    # 遍歷清單中的每個元素\n    for num in lst:\n        # 如果元素已存在於字典中，則累加其出現次數\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            # 如果元素不存在於字典中，則設置其初始出現次數為 1\n            count_dict[num] = 1\n    return count_dict\n\n# 測試函數\nresult = count_elements([1, 2, 2, 3, 3, 3])\nprint(result)  # 輸出: {1: 1, 2: 2, 3: 3}\n \n', 'tags': '', 'url': '清單排序.html'}, {'title': '字母計數器', 'text': '寫一個函數 `count_letters`，接受一個字串作為參數，並返回一個字典，該字典包含字串中每個字母出現的次數。例如：`count_letters("hello")` 應返回 `{\'h\': 1, \'e\': 1, \'l\': 2, \'o\': 1}`。 \n def count_letters(s):\n    letter_count = {}  # 初始化空字典用來存放字母出現次數\n    for letter in s:\n        if letter in letter_count:  # 如果字母已經在字典中，則增加其次數\n            letter_count[letter] += 1\n        else:\n            letter_count[letter] = 1  # 如果字母不在字典中，則設為1\n    return letter_count  # 返回字母及其次數的字典\n\n# 測試函數\nprint(count_letters("hello"))  # 輸出: {\'h\': 1, \'e\': 1, \'l\': 2, \'o\': 1}\n \n 寫一個函數 letter_positions，接受一個字串作為參數，並返回一個字典，該字典包含字串中每個字母出現的位置列表。例如：letter_positions("hello") 應返回 {\'h\': [0], \'e\': [1], \'l\': [2, 3], \'o\': [4]}。 \n def letter_positions(s):\n    positions = {}  # 初始化空字典用來存放字母的位置\n    for index, letter in enumerate(s):  # 使用 enumerate() 獲取字母和其位置\n        if letter in positions:  # 如果字母已經在字典中，則將位置添加到列表中\n            positions[letter].append(index)\n        else:\n            positions[letter] = [index]  # 如果字母不在字典中，則創建位置列表\n    return positions  # 返回字母及其位置的字典\n\n# 測試函數\nprint(letter_positions("hello"))  # 輸出: {\'h\': [0], \'e\': [1], \'l\': [2, 3], \'o\': [4]}\n \n 寫一個函數 first_last_count，接受一個字串作為參數，並返回一個字典，該字典包含字串中每個字母在首尾位置出現的次數。例如：first_last_count("hello world") 應返回 {\'h\': 1, \'d\': 1, \'o\': 2, \'w\': 1, \'r\': 1}。 \n def first_last_count(s):\n    count = {}  # 初始化空字典用來存放字母出現次數\n    if s:  # 檢查字串是否非空\n        # 確保首尾字母被計算\n        first = s[0]  # 字串的首字母\n        last = s[-1]  # 字串的尾字母\n\n        # 處理首字母\n        if first in count:\n            count[first] += 1\n        else:\n            count[first] = 1\n\n        # 處理尾字母\n        if last in count:\n            count[last] += 1\n        else:\n            count[last] = 1\n\n        # 如果首尾字母相同，則不重複計數\n        if first != last:\n            # 檢查中間部分字母\n            for letter in s[1:-1]:  # 遍歷首尾字母之間的字符\n                if letter in count:\n                    count[letter] += 1\n                else:\n                    count[letter] = 1\n\n    return count  # 返回字母出現次數的字典\n\n# 測試函數\nprint(first_last_count("hello world"))  # 輸出: {\'h\': 1, \'d\': 1, \'o\': 2, \'w\': 1, \'r\': 1}\n \n 寫一個函數 count_uppercase_letters，接受一個字串作為參數，並返回一個字典，該字典包含字串中每個大寫字母出現的次數。例如：count_uppercase_letters("Hello World") 應返回 {\'H\': 1, \'W\': 1}。 \n def count_uppercase_letters(s):\n    uppercase_count = {}  # 初始化空字典用來存放大寫字母出現次數\n    for letter in s:\n        if letter.isupper():  # 檢查字母是否為大寫字母\n            if letter in uppercase_count:  # 如果大寫字母已經出現過，則增加次數\n                uppercase_count[letter] += 1\n            else:\n                uppercase_count[letter] = 1  # 如果大寫字母是第一次出現，則設為1\n    return uppercase_count  # 返回包含大寫字母出現次數的字典\n\n# 測試函數\nprint(count_uppercase_letters("Hello World"))  # 輸出: {\'H\': 1, \'W\': 1}\n \n 寫一個函數 count_vowels，接受一個字串作為參數，並返回一個字典，該字典包含字串中每個母音出現的次數。例如：count_vowels("hello world") 應返回 {\'e\': 1, \'o\': 2}。 \n def count_vowels(s):\n    vowels = "aeiou"  # 定義母音字母\n    vowel_count = {}  # 初始化空字典用來存放母音的出現次數\n    \n    for letter in s:\n        if letter in vowels:  # 檢查字母是否是母音\n            if letter in vowel_count:  # 如果母音已經出現過，則增加次數\n                vowel_count[letter] += 1\n            else:\n                vowel_count[letter] = 1  # 如果母音是第一次出現，則設為1\n    return vowel_count  # 返回母音及其出現次數的字典\n\n# 測試函數\nprint(count_vowels("hello world"))  # 輸出: {\'e\': 1, \'o\': 2}\n \n 寫一個函數 count_non_letter_characters，接受一個字串作為參數，並返回一個字典，該字典包含字串中每個非字母符號出現的次數。例如：count_non_letter_characters("hello world!") 應返回 {\' \': 1, \'!\': 1}。 \n def count_non_letter_characters(s):\n    non_letters_count = {}  # 初始化空字典用來存放非字母字符的出現次數\n    \n    for char in s:\n        if not char.isalpha():  # 檢查字符是否為非字母\n            if char in non_letters_count:  # 如果字符已經在字典中，則增加次數\n                non_letters_count[char] += 1\n            else:\n                non_letters_count[char] = 1  # 如果字符是第一次出現，則設為1\n    return non_letters_count  # 返回非字母字符及其出現次數的字典\n\n# 測試函數\nprint(count_non_letter_characters("hello world!"))  # 輸出: {\' \': 1, \'!\': 1}\n \n', 'tags': '', 'url': '字母計數器.html'}, {'title': '進階Brython 繪圖', 'text': '繪製同心圓： \n 使用 for 迴圈和 if 條件，在畫布上繪製一組同心圓。每個圓的中心點相同，半徑隨著循環遞增。例如，繪製 10 個半徑從 10 到 100 的同心圓，每次增加 10。 \n import turtle\n\ndef draw_concentric_circles():\n    turtle.speed(0)  # 設定畫筆速度為最快\n    turtle.penup()  # 抬起畫筆，以便移動到起始位置\n\n    # 設定圓的中心點\n    turtle.goto(0, -100)  # 移動到圓心位置，y 軸往下偏移\n\n    # 繪製10個同心圓，半徑從10到100，每次增加10\n    for radius in range(10, 101, 10):\n        turtle.goto(0, -radius)  # 每次繪製圓之前，移動到新的圓心\n        turtle.pendown()  # 放下畫筆開始繪製\n        turtle.circle(radius)  # 繪製圓\n        turtle.penup()  # 抬起畫筆，準備移動到下一個圓心\n\n    turtle.done()  # 完成繪圖\n\n# 呼叫函數來繪製同心圓\ndraw_concentric_circles()\n \n \n 棋盤格圖案： \n 使用 for 迴圈和 if 條件，在畫布上繪製一個 8x8 的棋盤格圖案。每個格子為正方形，黑白相間。需要根據格子的行數和列數來決定格子的顏色。 \n import turtle\n\ndef draw_chessboard():\n    turtle.speed(0)  # 設定畫筆速度為最快\n    turtle.penup()  # 抬起畫筆，以便移動到起始位置\n    start_x = -200  # 棋盤的起始 x 座標\n    start_y = 200  # 棋盤的起始 y 座標\n    square_size = 50  # 每個正方形的大小\n\n    for row in range(8):  # 8 行\n        for col in range(8):  # 8 列\n            # 計算每個格子的顏色，根據行列的總和判斷顏色\n            if (row + col) % 2 == 0:\n                turtle.color("white")  # 白色\n            else:\n                turtle.color("black")  # 黑色\n\n            # 移動到當前格子的起始位置\n            turtle.goto(start_x + col * square_size, start_y - row * square_size)\n            turtle.pendown()  # 放下畫筆，開始繪製\n\n            # 繪製正方形\n            for _ in range(4):\n                turtle.forward(square_size)  # 畫一條邊\n                turtle.right(90)  # 轉90度，畫下一條邊\n\n            turtle.penup()  # 抬起畫筆，準備畫下一個格子\n\n    turtle.done()  # 完成繪圖\n\n# 呼叫函數來繪製棋盤格圖案\ndraw_chessboard()\n \n 螺旋線條： \n 使用 for 迴圈和基本數列，在畫布上繪製一個螺旋線條。每次迴圈增加線條的長度和角度。例如，從中心點開始，每次畫一段直線，長度增加 5 像素，角度增加 10 度。 \n import turtle\n\ndef draw_spiral():\n    turtle.speed(0)  # 設定畫筆速度為最快\n    turtle.penup()  # 抬起畫筆，移動到起始位置\n    turtle.goto(0, 0)  # 移動到畫布中心點\n    turtle.pendown()  # 放下畫筆開始繪製\n\n    length = 5  # 初始線條長度\n    angle = 10   # 每次旋轉的角度\n\n    for _ in range(50):  # 繪製50次，形成螺旋線條\n        turtle.forward(length)  # 繪製當前長度的線段\n        turtle.right(angle)  # 旋轉指定的角度\n        length += 5  # 每次迴圈增加5像素的長度\n\n    turtle.done()  # 完成繪圖\n\n# 呼叫函數來繪製螺旋線條\ndraw_spiral()\n \n 多邊形繪製： \n 使用 for 迴圈和 if 條件，在畫布上繪製不同邊數的正多邊形（例如：三角形、正方形、五邊形等）。例如，繪製 3 到 10 邊的多邊形，每個多邊形的邊數隨著循環遞增。 \n import turtle\n\ndef draw_polygons():\n    turtle.speed(0)  # 設定畫筆速度為最快\n    turtle.penup()  # 抬起畫筆，以便移動到起始位置\n    turtle.goto(-150, 100)  # 設定起始位置\n\n    for sides in range(3, 11):  # 從 3 邊到 10 邊\n        turtle.pendown()  # 放下畫筆開始繪製\n        angle = 360 / sides  # 計算每個角度（360° 除以邊數）\n        \n        for _ in range(sides):  # 繪製每個多邊形的每一條邊\n            turtle.forward(100)  # 繪製邊長 100 單位\n            turtle.left(angle)  # 旋轉至下一個角度\n\n        turtle.penup()  # 抬起畫筆，準備移動到下一個多邊形位置\n        turtle.forward(150)  # 移動到下一個多邊形的繪製位置\n\n    turtle.done()  # 完成繪圖\n\n# 呼叫函數來繪製不同邊數的正多邊形\ndraw_polygons()\n \n 隨機顏色的圓形： \n 使用 for 迴圈和 if 條件，在畫布上隨機位置繪製不同顏色的圓形。每次迴圈生成一個隨機的位置和顏色，並在該位置繪製一個圓形。 \n import turtle\nimport random\n\ndef draw_random_circles():\n    turtle.speed(0)  # 設定畫筆速度為最快\n    turtle.penup()  # 抬起畫筆\n\n    colors = ["red", "green", "blue", "yellow", "purple", "orange", "pink", "cyan", "magenta"]  # 顏色列表\n\n    for _ in range(20):  # 繪製 20 個圓形\n        # 隨機選擇顏色\n        color = random.choice(colors)\n        turtle.color(color)\n\n        # 隨機選擇圓形的位置\n        x = random.randint(-300, 300)\n        y = random.randint(-300, 300)\n        turtle.goto(x, y)\n\n        turtle.pendown()  # 放下畫筆開始繪製\n\n        # 繪製圓形，半徑 30 單位\n        turtle.begin_fill()  # 開始填充顏色\n        turtle.circle(30)  # 繪製圓形，半徑 30\n        turtle.end_fill()  # 結束填充顏色\n\n        turtle.penup()  # 抬起畫筆，準備繪製下一個圓形\n\n    turtle.done()  # 完成繪圖\n\n# 呼叫函數來繪製隨機顏色的圓形\ndraw_random_circles()\n \n 雪花圖案： \n 使用 for 迴圈和基本數列，在畫布上繪製一個簡單的雪花圖案。雪花的每個枝條對稱排列，例如從中心向外延伸的六條對稱直線。 \n import turtle\n\ndef draw_snowflake():\n    turtle.speed(0)  # 設定畫筆速度為最快\n    turtle.penup()  # 抬起畫筆\n    turtle.goto(0, 0)  # 移動到畫布中心\n    turtle.pendown()  # 放下畫筆\n\n    for _ in range(6):  # 繪製6條對稱的枝條\n        turtle.forward(100)  # 向前畫一條直線，長度為100\n        turtle.backward(100)  # 返回到中心\n        turtle.left(60)  # 旋轉60度，繪製下一條直線\n\n    turtle.done()  # 完成繪圖\n\n# 呼叫函數來繪製雪花圖案\ndraw_snowflake()\n \n 旋轉方形： \n 使用 for 迴圈和基本數列，在畫布上繪製一組旋轉的方形。每次迴圈方形的角度隨著循環增加，例如每次增加 15 度，並且每個方形中心相同。 \n import turtle\n\ndef draw_rotating_squares():\n    turtle.speed(0)  # 設定畫筆速度為最快\n    turtle.penup()  # 抬起畫筆\n    turtle.goto(0, 0)  # 移動到畫布中心\n    turtle.pendown()  # 放下畫筆\n\n    for angle in range(0, 360, 15):  # 從 0 到 360，每次增加 15 度\n        turtle.setheading(angle)  # 設定畫筆的朝向（角度）\n        \n        # 繪製方形\n        for _ in range(4):  # 方形有四條邊\n            turtle.forward(100)  # 每條邊長度 100 單位\n            turtle.left(90)  # 轉 90 度，形成直角\n\n    turtle.done()  # 完成繪圖\n\n# 呼叫函數來繪製旋轉的方形\ndraw_rotating_squares()\n \n 備註：漸變色矩形要使用IDE( 該環境不支持圖形界面 ) \n 使用 for 迴圈和基本數列，在畫布上繪製一組漸變色的矩形。每個矩形的顏色隨著循環變化，例如從紅色逐漸變為藍色。 \n turtle.Screen()._colorstr  這個方法是內部私有方法，不適合直接使用來獲取顏色的 RGB 值 \n import turtle\n\n# 顏色漸變的計算函數\ndef interpolate_color(start_color, end_color, factor):\n    # 將顏色從字符串轉換為 RGB\n    start_rgb = turtle.Screen()._colorstr(start_color)\n    end_rgb = turtle.Screen()._colorstr(end_color)\n\n    # 計算漸變顏色\n    r = start_rgb[0] + factor * (end_rgb[0] - start_rgb[0])\n    g = start_rgb[1] + factor * (end_rgb[1] - start_rgb[1])\n    b = start_rgb[2] + factor * (end_rgb[2] - start_rgb[2])\n\n    return r, g, b\n\ndef draw_gradient_rectangles():\n    turtle.speed(0)  # 設定畫筆速度為最快\n    turtle.penup()  # 抬起畫筆\n    turtle.goto(-150, 0)  # 移動到起始位置\n    turtle.pendown()  # 放下畫筆\n\n    start_color = "red"  # 起始顏色\n    end_color = "blue"  # 結束顏色\n\n    for i in range(10):  # 繪製 10 個矩形\n        # 計算顏色漸變\n        factor = i / 9  # 計算漸變因子，從 0 到 1\n        color = interpolate_color(start_color, end_color, factor)\n\n        turtle.color(color)  # 設定顏色\n\n        # 繪製矩形\n        for _ in range(2):\n            turtle.forward(100 + i * 10)  # 每次增加 10 像素的長度\n            turtle.left(90)\n            turtle.forward(50 + i * 5)  # 每次增加 5 像素的寬度\n            turtle.left(90)\n\n        turtle.penup()\n        turtle.goto(-150 + (i + 1) * 10, 0)  # 移動到下一個位置\n        turtle.pendown()\n\n    turtle.done()  # 完成繪圖\n\n# 呼叫函數來繪製漸變色矩形\ndraw_gradient_rectangles()\n \n 修正後程式： 星星圖案： \n 使用 for 迴圈和 if 條件，在畫布上繪製一組星星圖案。每次迴圈在隨機位置繪製一個五角星，星星的大小也可以隨機變化。 \n import turtle\nimport random\n\ndef draw_star(x, y, size):\n    turtle.penup()  # 抬起畫筆，準備移動到指定位置\n    turtle.goto(x, y)  # 移動到指定位置\n    turtle.pendown()  # 放下畫筆\n\n    turtle.begin_fill()  # 開始填充顏色\n\n    for _ in range(5):  # 繪製五角星的五條邊\n        turtle.forward(size)  # 向前畫一條邊\n        turtle.right(144)  # 轉動144度，繪製星星的角度\n\n    turtle.end_fill()  # 結束填充顏色\n\ndef draw_random_stars():\n    turtle.speed(0)  # 設定畫筆速度為最快\n    turtle.bgcolor("black")  # 設定背景為黑色，使星星顯得更加明顯\n\n    for _ in range(20):  # 繪製 20 顆隨機位置和大小的星星\n        x = random.randint(-300, 300)  # 隨機生成 x 坐標\n        y = random.randint(-300, 300)  # 隨機生成 y 坐標\n        size = random.randint(10, 30)  # 隨機生成星星的大小\n        draw_star(x, y, size)  # 在隨機位置繪製星星\n\n    turtle.done()  # 完成繪圖\n\n# 呼叫函數來繪製星星圖案\ndraw_random_stars()\n \n 曼陀羅圖案： \n 使用 for 迴圈和基本數列，在畫布上繪製一個簡單的曼陀羅圖案。曼陀羅圖案是一種對稱的幾何圖案，可以由多個同心圓和圓周上的線條組成，每個線條從中心點向外對稱分佈。 \n import turtle\n\ndef draw_mandala():\n    turtle.speed(0)  # 設定畫筆速度為最快\n    turtle.bgcolor("white")  # 設定背景顏色為白色\n\n    # 繪製同心圓和圓周上的對稱線條\n    for i in range(6):  # 繪製六個同心圓\n        turtle.penup()  # 抬起畫筆\n        turtle.goto(0, -20 * (i + 1))  # 每次將畫筆移到新的圓心位置\n        turtle.pendown()  # 放下畫筆\n        turtle.circle(20 * (i + 1))  # 繪製圓，半徑隨著循環增大\n\n    # 繪製圓周上的對稱線條\n    for i in range(12):  # 繪製 12 條對稱線條\n        turtle.penup()  # 抬起畫筆\n        turtle.goto(0, 0)  # 回到中心點\n        turtle.setheading(i * 30)  # 設定角度，每次增加 30 度\n        turtle.pendown()  # 放下畫筆\n        turtle.forward(200)  # 畫線條\n\n    turtle.done()  # 完成繪圖\n\n# 呼叫函數來繪製曼陀羅圖案\ndraw_mandala()\n \n', 'tags': '', 'url': '進階Brython 繪圖.html'}, {'title': '基礎Brython 繪圖', 'text': "繪製直線： 使用簡單的 for 迴圈繪製若干條平行的直線，例如從畫布的左邊到右邊，每次增加固定的間距。 \n import matplotlib.pyplot as plt\n\n# 設定畫布\nplt.figure(figsize=(6, 6))\n\n# 設定直線的數量與間距\nnum_lines = 10  # 直線的數量\nline_spacing = 0.1  # 直線的垂直間距\n\n# 使用 for 迴圈繪製平行直線\nfor i in range(num_lines):\n    y = i * line_spacing  # 計算每條直線的 y 座標\n    plt.plot([0, 1], [y, y], color='blue')  # 繪製從左到右的直線\n\n# 設定畫布顯示範圍\nplt.xlim(0, 1)\nplt.ylim(0, (num_lines - 1) * line_spacing)\n\n# 顯示繪製結果\nplt.title('Parallel Lines')\nplt.xlabel('X-axis')\nplt.ylabel('Y-axis')\nplt.show()\n \n 繪製矩形： 使用 for 迴圈在畫布上繪製若干個矩形，每次增加固定的間距和尺寸。 \n import turtle  # 引入 turtle 模組\n\n# 設定畫布\nscreen = turtle.Screen()\nscreen.setup(width=600, height=600)\n\n# 設定 turtle\npen = turtle.Turtle()\npen.speed(10)  # 設定繪圖速度\n\n# 繪製矩形的函數\ndef draw_rectangle(width, height):\n    for _ in range(2):  # 每個矩形有四條邊，繪製兩次來形成矩形\n        pen.forward(width)  # 向前移動指定的寬度\n        pen.left(90)  # 轉90度\n        pen.forward(height)  # 向前移動指定的高度\n        pen.left(90)  # 轉90度\n\n# 使用 for 迴圈繪製若干個矩形\ninitial_width = 50  # 初始矩形寬度\ninitial_height = 30  # 初始矩形高度\nspacing = 20  # 矩形間距\nnum_rectangles = 5  # 矩形數量\n\n# 繪製矩形\nfor i in range(num_rectangles):\n    draw_rectangle(initial_width + i * spacing, initial_height + i * spacing)  # 隨著每個迴圈增加寬度和高度\n    pen.penup()  # 抬起筆，移動到下一個起始位置\n    pen.forward(spacing)  # 向前移動間距\n    pen.pendown()  # 放下筆繼續繪製\n\n# 完成後停止\nturtle.done()\n \n 繪製圓形： 使用 for 迴圈在畫布上繪製若干個圓形，每次增加固定的半徑和位置。 \n import turtle  # 引入 turtle 模組\n\n# 設定畫布\nscreen = turtle.Screen()\nscreen.setup(width=600, height=600)\n\n# 設定 turtle\npen = turtle.Turtle()\npen.speed(10)  # 設定繪圖速度\n\n# 繪製圓形的函數\ndef draw_circle(radius):\n    pen.circle(radius)  # 根據給定的半徑繪製圓形\n\n# 使用 for 迴圈繪製若干個圓形\ninitial_radius = 20  # 初始圓形半徑\nradius_increase = 20  # 每次增長的半徑\nnum_circles = 5  # 圓形數量\n\n# 繪製圓形\nfor i in range(num_circles):\n    pen.penup()  # 抬起筆，準備移動到下一個圓形位置\n    pen.setposition(0, - (initial_radius + i * radius_increase))  # 設定圓形的中心位置\n    pen.pendown()  # 放下筆開始繪製\n    draw_circle(initial_radius + i * radius_increase)  # 隨著每次迴圈增加圓形半徑\n\n# 完成後停止\nturtle.done()\n \n 繪製不同顏色的線條： 使用 for 迴圈在畫布上繪製若干條不同顏色的線條，每次改變顏色。 \n import turtle  # 引入 turtle 模組\n\n# 設定畫布\nscreen = turtle.Screen()\nscreen.setup(width=600, height=600)\n\n# 設定 turtle\npen = turtle.Turtle()\npen.speed(10)  # 設定繪圖速度\n\n# 定義顏色列表\ncolors = ['red', 'green', 'blue', 'yellow', 'purple']\n\n# 使用 for 迴圈繪製不同顏色的線條\nnum_lines = len(colors)  # 線條的數量等於顏色的數量\n\n# 繪製不同顏色的線條\nfor i in range(num_lines):\n    pen.penup()  # 抬起筆，準備移動到下一個起始位置\n    pen.setposition(-200 + i * 100, 0)  # 設定每條線的起始位置\n    pen.pendown()  # 放下筆開始繪製\n    pen.pencolor(colors[i])  # 設定當前線條的顏色\n    pen.forward(100)  # 繪製線條\n\n# 完成後停止\nturtle.done()\n \n 繪製格子圖案： 使用 for 迴圈和 if 條件在畫布上繪製簡單的格子圖案，例如 4x4 的格子，每個格子是正方形。 \n import turtle  # 引入 turtle 模組\n\n# 設定畫布\nscreen = turtle.Screen()\nscreen.setup(width=600, height=600)\n\n# 設定 turtle\npen = turtle.Turtle()\npen.speed(10)  # 設定繪圖速度\n\n# 定義繪製正方形的函數\ndef draw_square(size):\n    for _ in range(4):  # 每個正方形有四邊\n        pen.forward(size)  # 向前畫一邊\n        pen.left(90)  # 轉90度\n\n# 設定格子的大小與間距\nsquare_size = 50  # 每個正方形的邊長\nspacing = 10  # 每個格子之間的間距\ngrid_size = 4  # 格子的行列數（4x4）\n\n# 使用 for 迴圈繪製格子圖案\nfor row in range(grid_size):\n    for col in range(grid_size):\n        pen.penup()  # 抬起筆，準備移動到格子位置\n        pen.setposition(col * (square_size + spacing), -row * (square_size + spacing))  # 設定每個格子的位置\n        pen.pendown()  # 放下筆開始繪製\n        draw_square(square_size)  # 繪製正方形\n\n# 完成後停止\nturtle.done()\n \n 繪製對角線： 使用 for 迴圈在畫布上繪製從左上角到右下角的對角線。 \n import turtle  # 引入 turtle 模組\n\n# 設定畫布\nscreen = turtle.Screen()\nscreen.setup(width=600, height=600)\n\n# 設定 turtle\npen = turtle.Turtle()\npen.speed(10)  # 設定繪圖速度\n\n# 定義繪製對角線的函數\ndef draw_diagonal(length):\n    for _ in range(length):  # 循環繪製對角線\n        pen.forward(1)  # 向前移動1個單位\n        pen.left(90)  # 轉90度\n\n# 設定對角線的長度\nline_length = 200  # 設定對角線的長度\n\n# 使用 for 迴圈繪製對角線\npen.penup()  # 抬起筆，準備移動到左上角\npen.setposition(-line_length // 2, line_length // 2)  # 設定起始位置（左上角）\npen.pendown()  # 放下筆開始繪製\npen.setposition(line_length // 2, -line_length // 2)  # 繪製線條到右下角\n\n# 完成後停止\nturtle.done()\n \n 繪製交錯矩形： 使用 for 迴圈在畫布上繪製若干個交錯排列的矩形，形成交錯圖案。 \n import turtle  # 引入 turtle 模組\n\n# 設定畫布\nscreen = turtle.Screen()\nscreen.setup(width=600, height=600)\n\n# 設定 turtle\npen = turtle.Turtle()\npen.speed(10)  # 設定繪圖速度\n\n# 定義繪製矩形的函數\ndef draw_rectangle(width, height):\n    for _ in range(2):  # 每個矩形有四邊，繪製兩次\n        pen.forward(width)  # 向前移動寬度\n        pen.left(90)  # 轉90度\n        pen.forward(height)  # 向前移動高度\n        pen.left(90)  # 轉90度\n\n# 設定矩形的大小與間距\nrect_width = 100  # 矩形的寬度\nrect_height = 50  # 矩形的高度\nnum_rectangles = 5  # 繪製的矩形數量\n\n# 使用 for 迴圈繪製交錯排列的矩形\nfor i in range(num_rectangles):\n    pen.penup()  # 抬起筆，準備移動到下一個矩形位置\n    pen.setposition(-200 + i * 40, 200 - i * 20)  # 設定每個矩形的起始位置，改變位置實現交錯\n    pen.pendown()  # 放下筆開始繪製\n    if i % 2 == 0:\n        pen.setheading(0)  # 偶數索引的矩形保持水平\n    else:\n        pen.setheading(45)  # 奇數索引的矩形旋轉45度，實現交錯排列\n    draw_rectangle(rect_width, rect_height)  # 繪製矩形\n\n# 完成後停止\nturtle.done()\n \n 繪製同心圓： 使用 for 迴圈在畫布上繪製若干個同心圓，每次增加固定的半徑。 \n import turtle  # 引入 turtle 模組\n\n# 設定畫布\nscreen = turtle.Screen()\nscreen.setup(width=600, height=600)\n\n# 設定 turtle\npen = turtle.Turtle()\npen.speed(10)  # 設定繪圖速度\n\n# 定義繪製圓形的函數\ndef draw_circle(radius):\n    pen.circle(radius)  # 根據給定的半徑繪製圓形\n\n# 設定圓形的初始半徑與增長值\ninitial_radius = 20  # 初始圓形半徑\nradius_increase = 20  # 每次增長的半徑\nnum_circles = 5  # 圓形數量\n\n# 使用 for 迴圈繪製同心圓\nfor i in range(num_circles):\n    pen.penup()  # 抬起筆，準備移動到圓形中心\n    pen.setposition(0, - (initial_radius + i * radius_increase))  # 設定圓形的中心位置\n    pen.pendown()  # 放下筆開始繪製\n    draw_circle(initial_radius + i * radius_increase)  # 繪製每個同心圓，隨著每次迴圈增加半徑\n\n# 完成後停止\nturtle.done()\n \n 繪製同心方形： 使用 for 迴圈在畫布上繪製若干個同心方形，每次增加固定的邊長。 \n import turtle  # 引入 turtle 模組\n\n# 設定畫布\nscreen = turtle.Screen()\nscreen.setup(width=600, height=600)\n\n# 設定 turtle\npen = turtle.Turtle()\npen.speed(10)  # 設定繪圖速度\n\n# 定義繪製方形的函數\ndef draw_square(side_length):\n    for _ in range(4):  # 每個方形有四條邊\n        pen.forward(side_length)  # 向前移動邊長\n        pen.left(90)  # 轉90度\n\n# 設定方形的初始邊長與增長值\ninitial_side_length = 50  # 初始方形邊長\nside_length_increase = 20  # 每次增長的邊長\nnum_squares = 5  # 方形數量\n\n# 使用 for 迴圈繪製同心方形\nfor i in range(num_squares):\n    pen.penup()  # 抬起筆，準備移動到方形的位置\n    pen.setposition(- (initial_side_length + i * side_length_increase) / 2, (initial_side_length + i * side_length_increase) / 2)  # 設定方形的起始位置\n    pen.pendown()  # 放下筆開始繪製\n    draw_square(initial_side_length + i * side_length_increase)  # 繪製每個同心方形，隨著每次迴圈增加邊長\n\n# 完成後停止\nturtle.done()\n \n 繪製簡單的線條圖： 使用 for 迴圈在畫布上繪製若干條從畫布中心向外輻射的線條。 \n import turtle  # 引入 turtle 模組\n\n# 設定畫布\nscreen = turtle.Screen()\nscreen.setup(width=600, height=600)\n\n# 設定 turtle\npen = turtle.Turtle()\npen.speed(10)  # 設定繪圖速度\n\n# 定義繪製線條的函數\ndef draw_line(length):\n    pen.forward(length)  # 向前繪製一條線條\n\n# 設定線條的長度與數量\nline_length = 200  # 每條線條的長度\nnum_lines = 12  # 線條的數量（從中心向外輻射）\n\n# 使用 for 迴圈繪製從畫布中心向外輻射的線條\npen.penup()  # 抬起筆，準備移動到畫布中心\npen.setposition(0, 0)  # 設定畫布的中心位置\npen.pendown()  # 放下筆開始繪製\n\nfor i in range(num_lines):\n    pen.setheading(i * (360 / num_lines))  # 設定每條線條的角度，使其均勻分布\n    draw_line(line_length)  # 繪製線條\n\n# 完成後停止\nturtle.done()\n \n", 'tags': '', 'url': '基礎Brython 繪圖.html'}, {'title': 'Brython', 'text': '從 1 累加到 100: \n 1 add to 100 \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從 1 累加到 100 part2: \n 1 add to 100 cango_three_gears BSnake AI Tetris Rotating Block \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n \n \n', 'tags': '', 'url': 'Brython.html'}]};